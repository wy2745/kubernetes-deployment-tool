package classType

import (
	"gopkg.in/inf.v0"
	"fmt"
)


//type Metadata struct{
//	Name string `json:"name,omitempty"`
//	GenerateName string `json:"generateName,omitempty"`
//	SelfLink string `json:"selfLink,omitempty"`
//	ResourceVersion string `json:"resourceVersion,omitempty"`
//	Namespace string `json:"namespace,omitempty"`
//	Uid string `json:"uid,omitempty"`
//	Generation int `json:"generation,omitempty"`
//	CreationTimestamp string `json:"CreationTimestamp,omitempty"`
//	DeletionTimestamp string `json:"deletionTimestamp,omitempty"`
//	DeletionGracePeriodSeconds int `json:"deletionGracePeriodSeconds,omitempty"`
//}
//
//
//type Item struct{
//	Kind string `json:"kind,omitempty"`
//	ApiVersion string `json:"apiVersion,omitempty"`
//	Metadata Metadata `json:"metadata,omitempty"`
//	Spec Spec `json:"spec,omitempty"`
//	Status Status `json:"status,omitempty"`
//}
//
//type Spec struct{
//	PodCIDR string `json:"podCIDR,omitempty"`
//	ExternalID string `json:"externalID,omitempty"`
//	ProviderID string `json:"providerID,omitempty"`
//	Unschedulable bool `json:"unschedulable,omitempty"`
//}
//
//type Condition struct{
//	Type string `json:"type,omitempty"`
//	Status string `json:"status,omitempty"`
//	LastHeartbeatTime string `json:"LastHeartbeatTime,omitempty"`
//	LastTransitionTime string `json:"lastTransitionTime,omitempty"`
//	Reason string `json:"reason,omitempty"`
//	Message string `json:"message,omitempty"`
//}
//type Status struct{
//	Phase string `json:"phase,omitempty"`
//	Conditions []Condition `json:"conditions,omitempty"`
//	Addresses []Address `json:"addresses,omitempty"`
//}
//type Address struct{
//	Type string `json:"type,omitempty"`
//	Address string `json:"address,omitempty"`
//}
//
//type KubectlEndpoint struct{
//	Port int `json:"Port,omitempty"`
//}
//type DaemonEndpoints struct{
//	KubeletEndpoints KubectlEndpoint `json:"kubeletEndpoint,omitempty"`
//}
//type NodeInfo struct{
//	MachineID string `json:"machineID,omitempty"`
//	SystemUUID string `json:"systemUUID,omitempty"`
//	BootID string `json:"bootID,omitempty"`
//	KernelVersion string `json:"kernelVersion,omitempty"`
//	OsImage string `json:"osImage,omitempty"`
//	ContainerRuntimeVersion string `json:"containerRuntimeVersion,omitempty"`
//	KubeletVersion string `json:"kubeletVersion,omitempty"`
//	KubeProxyVersion string `json:"kubeProxyVersion,omitempty"`
//}
//
//
//
//type Node struct{
//
//	Kind  string `json:"kind,omitempty"`
//	ApiVersion  string `json:"apiVersion,omitempty"`
//	Metadata Metadata `json:"metadata,omitempty"`
//	Items []Item `json:"items,omitempty"`
//	DaemonEndpoints DaemonEndpoints `json:"daemonEndpoints,omitempty"`
//	NodeInfo NodeInfo `json:"nodeInfo,omitempty"`
//}


type zone struct {
	name   string
	offset int
	isDST  bool
}

type zoneTrans struct {
	when         int64
	index        uint8
	isstd, isutc bool
}
type Location struct {
	name       string
	zone       []zone
	tx         []zoneTrans

	// Most lookups will be for the current time.
	// To avoid the binary search through tx, keep a
	// static one-element cache that gives the correct
	// zone for the time when the Location was created.
	// if cacheStart <= t <= cacheEnd,
	// lookup can return cacheZone.
	// The units for cacheStart and cacheEnd are seconds
	// since January 1, 1970 UTC, to match the argument
	// to lookup.
	cacheStart int64
	cacheEnd   int64
	cacheZone  *zone
}
type Time struct {
	// sec gives the number of seconds elapsed since
	// January 1, year 1 00:00:00 UTC.
	sec  int64

	// nsec specifies a non-negative nanosecond
	// offset within the second named by Seconds.
	// It must be in the range [0, 999999999].
	nsec int32

	// loc specifies the Location that should be used to
	// determine the minute, hour, month, day, and year
	// that correspond to this Time.
	// Only the zero Time has a nil Location.
	// In that case it is interpreted to mean UTC.
	loc  *Location
}


// The comments for the structs and fields can be used from go-resful to
// generate Swagger API documentation for its models. Please read this PR for more
// information on the implementation: https://github.com/emicklei/go-restful/pull/215
//
// TODOs are ignored from the parser (e.g. TODO(andronat):... || TODO:...) if and only if
// they are on one line! For multiple line or blocks that you want to ignore use ---.
// Any context after a --- is ignored and not exported to the SwaggerAPI.
//
// The aforementioned methods can be generated by hack/update-generated-swagger-docs.sh

// Common string formats
// ---------------------
// Many fields in this API have formatting requirements. The commonly used
// formats are defined here.
//
// C_IDENTIFIER:  This is a string that conforms to the definition of an "identifier"
//     in the C language. This is captured by the following regex:
//         [A-Za-z_][A-Za-z0-9_]*
//     This defines the format, but not the length restriction, which should be
//     specified at the definition of any field of this type.
//
// DNS_LABEL:  This is a string, no more than 63 characters long, that conforms
//     to the definition of a "label" in RFCs 1035 and 1123. This is captured
//     by the following regex:
//         [a-z0-9]([-a-z0-9]*[a-z0-9])?
//
// DNS_SUBDOMAIN:  This is a string, no more than 253 characters long, that conforms
//      to the definition of a "subdomain" in RFCs 1035 and 1123. This is captured
//      by the following regex:
//         [a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*
//     or more simply:
//         DNS_LABEL(\.DNS_LABEL)*
//
// IANA_SVC_NAME: This is a string, no more than 15 characters long, that
//      conforms to the definition of IANA service name in RFC 6335.
//      It must contains at least one letter [a-z] and it must contains only [a-z0-9-].
//      Hypens ('-') cannot be leading or trailing character of the string
//      and cannot be adjacent to other hyphens.

// ObjectMeta is metadata that all persisted resources must have, which includes all objects
// users must create.
type ObjectMeta struct {
	Name                       string `json:"name,omitempty"`

	GenerateName               string `json:"generateName,omitempty"`

	Namespace                  string `json:"namespace,omitempty"`

	SelfLink                   string `json:"selfLink,omitempty"`

	UID                        string `json:"uid,omitempty"`

	ResourceVersion            string `json:"resourceVersion,omitempty"`

	Generation                 int64 `json:"generation,omitempty"`

	CreationTimestamp          string `json:"creationTimestamp,omitempty"`

	DeletionTimestamp          *Time `json:"deletionTimestamp,omitempty"`

	DeletionGracePeriodSeconds *int64 `json:"deletionGracePeriodSeconds,omitempty"`

	Labels                     map[string]string `json:"labels,omitempty"`

	Annotations                map[string]string `json:"annotations,omitempty"`
}

const (
	NamespaceDefault string = "default"
	NamespaceAll string = ""
)

type Volume struct {
	Name string `json:"name"`

	VolumeSource `json:",inline"`
}

type VolumeSource struct {
	HostPath              *HostPathVolumeSource `json:"hostPath,omitempty"`

	EmptyDir              *EmptyDirVolumeSource `json:"emptyDir,omitempty"`

	GCEPersistentDisk     *GCEPersistentDiskVolumeSource `json:"gcePersistentDisk,omitempty"`

	AWSElasticBlockStore  *AWSElasticBlockStoreVolumeSource `json:"awsElasticBlockStore,omitempty"`

	GitRepo               *GitRepoVolumeSource `json:"gitRepo,omitempty"`

	Secret                *SecretVolumeSource `json:"secret,omitempty"`

	NFS                   *NFSVolumeSource `json:"nfs,omitempty"`

	ISCSI                 *ISCSIVolumeSource `json:"iscsi,omitempty"`

	Glusterfs             *GlusterfsVolumeSource `json:"glusterfs,omitempty"`

	PersistentVolumeClaim *PersistentVolumeClaimVolumeSource `json:"persistentVolumeClaim,omitempty"`

	RBD                   *RBDVolumeSource `json:"rbd,omitempty"`

	FlexVolume            *FlexVolumeSource `json:"flexVolume,omitempty"`

	Cinder                *CinderVolumeSource `json:"cinder,omitempty"`

	CephFS                *CephFSVolumeSource `json:"cephfs,omitempty"`

	Flocker               *FlockerVolumeSource `json:"flocker,omitempty"`

	DownwardAPI           *DownwardAPIVolumeSource `json:"downwardAPI,omitempty"`
	FC                    *FCVolumeSource `json:"fc,omitempty"`
	AzureFile             *AzureFileVolumeSource `json:"azureFile,omitempty"`
	ConfigMap             *ConfigMapVolumeSource `json:"configMap,omitempty"`
}

type PersistentVolumeClaimVolumeSource struct {
	ClaimName string `json:"claimName"`

	ReadOnly  bool `json:"readOnly,omitempty"`
}

type PersistentVolumeSource struct {
	GCEPersistentDisk    *GCEPersistentDiskVolumeSource `json:"gcePersistentDisk,omitempty"`

	AWSElasticBlockStore *AWSElasticBlockStoreVolumeSource `json:"awsElasticBlockStore,omitempty"`

	HostPath             *HostPathVolumeSource `json:"hostPath,omitempty"`

	Glusterfs            *GlusterfsVolumeSource `json:"glusterfs,omitempty"`

	NFS                  *NFSVolumeSource `json:"nfs,omitempty"`

	RBD                  *RBDVolumeSource `json:"rbd,omitempty"`

	ISCSI                *ISCSIVolumeSource `json:"iscsi,omitempty"`

	Cinder               *CinderVolumeSource `json:"cinder,omitempty"`

	CephFS               *CephFSVolumeSource `json:"cephfs,omitempty"`

	FC                   *FCVolumeSource `json:"fc,omitempty"`
	Flocker              *FlockerVolumeSource `json:"flocker,omitempty"`
	FlexVolume           *FlexVolumeSource `json:"flexVolume,omitempty"`
	AzureFile            *AzureFileVolumeSource `json:"azureFile,omitempty"`
}

type TypeMeta struct {
	Kind       string `json:"kind,omitempty"`

	APIVersion string `json:"apiVersion,omitempty"`
}
type ListMeta struct {
	SelfLink        string `json:"selfLink,omitempty"`

	ResourceVersion string `json:"resourceVersion,omitempty"`
}
type PersistentVolume struct {
	TypeMeta `json:",inline"`

	ObjectMeta `json:"metadata,omitempty"`

	Spec   PersistentVolumeSpec `json:"spec,omitempty"`

	Status PersistentVolumeStatus `json:"status,omitempty"`
}

type PersistentVolumeSpec struct {
	Capacity                      ResourceList `json:"capacity,omitempty"`

	PersistentVolumeSource `json:",inline"`

	AccessModes                   []PersistentVolumeAccessMode `json:"accessModes,omitempty"`

	ClaimRef                      *ObjectReference `json:"claimRef,omitempty"`

	PersistentVolumeReclaimPolicy PersistentVolumeReclaimPolicy `json:"persistentVolumeReclaimPolicy,omitempty"`
}

type PersistentVolumeReclaimPolicy string

const (
	PersistentVolumeReclaimRecycle PersistentVolumeReclaimPolicy = "Recycle"

	PersistentVolumeReclaimDelete PersistentVolumeReclaimPolicy = "Delete"

	PersistentVolumeReclaimRetain PersistentVolumeReclaimPolicy = "Retain"
)

type PersistentVolumeStatus struct {
	Phase   PersistentVolumePhase `json:"phase,omitempty"`

	Message string `json:"message,omitempty"`

	Reason  string `json:"reason,omitempty"`
}

type PersistentVolumeList struct {
	TypeMeta `json:",inline"`

	ListMeta `json:"metadata,omitempty"`

	Items []PersistentVolume `json:"items"`
}

type PersistentVolumeClaim struct {
	TypeMeta `json:",inline"`

	ObjectMeta `json:"metadata,omitempty"`

	Spec   PersistentVolumeClaimSpec `json:"spec,omitempty"`

	Status PersistentVolumeClaimStatus `json:"status,omitempty"`
}

type PersistentVolumeClaimList struct {
	TypeMeta `json:",inline"`

	ListMeta `json:"metadata,omitempty"`

	Items []PersistentVolumeClaim `json:"items"`
}

type PersistentVolumeClaimSpec struct {
	AccessModes []PersistentVolumeAccessMode `json:"accessModes,omitempty"`

	Resources   ResourceRequirements `json:"resources,omitempty"`

	VolumeName  string `json:"volumeName,omitempty"`
}

type PersistentVolumeClaimStatus struct {
	Phase       PersistentVolumeClaimPhase `json:"phase,omitempty"`

	AccessModes []PersistentVolumeAccessMode `json:"accessModes,omitempty"`

	Capacity    ResourceList `json:"capacity,omitempty"`
}

type PersistentVolumeAccessMode string

const (
	ReadWriteOnce PersistentVolumeAccessMode = "ReadWriteOnce"

	ReadOnlyMany PersistentVolumeAccessMode = "ReadOnlyMany"

	ReadWriteMany PersistentVolumeAccessMode = "ReadWriteMany"
)

type PersistentVolumePhase string

const (
	VolumePending PersistentVolumePhase = "Pending"

	VolumeAvailable PersistentVolumePhase = "Available"

	VolumeBound PersistentVolumePhase = "Bound"

	VolumeReleased PersistentVolumePhase = "Released"

	VolumeFailed PersistentVolumePhase = "Failed"
)

type PersistentVolumeClaimPhase string

const (
	ClaimPending PersistentVolumeClaimPhase = "Pending"
	ClaimBound PersistentVolumeClaimPhase = "Bound"
)

type HostPathVolumeSource struct {
	Path string `json:"path"`
}

type EmptyDirVolumeSource struct {
	Medium StorageMedium `json:"medium,omitempty"`
}

type GlusterfsVolumeSource struct {
	EndpointsName string `json:"endpoints"`

	Path          string `json:"path"`

	ReadOnly      bool `json:"readOnly,omitempty"`
}

type RBDVolumeSource struct {
	CephMonitors []string `json:"monitors"`
	RBDImage     string `json:"image"`
	FSType       string `json:"fsType,omitempty"`
	RBDPool      string `json:"pool"`
	RadosUser    string `json:"user"`
	Keyring      string `json:"keyring"`
	SecretRef    *LocalObjectReference `json:"secretRef"`
	ReadOnly     bool `json:"readOnly,omitempty"`
}

type CinderVolumeSource struct {
	VolumeID string `json:"volumeID"`
	FSType   string `json:"fsType,omitempty"`
	ReadOnly bool `json:"readOnly,omitempty"`
}

type CephFSVolumeSource struct {
	Monitors   []string `json:"monitors"`
	Path       string `json:"path,omitempty"`
	User       string `json:"user,omitempty"`
	SecretFile string `json:"secretFile,omitempty"`
	SecretRef  *LocalObjectReference `json:"secretRef,omitempty"`
	ReadOnly   bool `json:"readOnly,omitempty"`
}

type FlockerVolumeSource struct {
	DatasetName string `json:"datasetName"`
}

type StorageMedium string

const (
	StorageMediumDefault StorageMedium = ""
	StorageMediumMemory StorageMedium = "Memory"
)

type Protocol string

const (
	ProtocolTCP Protocol = "TCP"
	ProtocolUDP Protocol = "UDP"
)

type GCEPersistentDiskVolumeSource struct {
	PDName    string `json:"pdName"`
	FSType    string `json:"fsType,omitempty"`
	Partition int32 `json:"partition,omitempty"`
	ReadOnly  bool `json:"readOnly,omitempty"`
}

type FlexVolumeSource struct {
	Driver    string `json:"driver"`
	FSType    string `json:"fsType,omitempty"`
	SecretRef *LocalObjectReference `json:"secretRef,omitempty"`
	ReadOnly  bool `json:"readOnly,omitempty"`
	Options   map[string]string `json:"options,omitempty"`
}

type AWSElasticBlockStoreVolumeSource struct {
	VolumeID  string `json:"volumeID"`

	FSType    string `json:"fsType,omitempty"`
	Partition int32 `json:"partition,omitempty"`
	ReadOnly  bool `json:"readOnly,omitempty"`
}

type GitRepoVolumeSource struct {
	Repository string `json:"repository"`
	Revision   string `json:"revision,omitempty"`
	Directory  string `json:"directory,omitempty"`
}

type SecretVolumeSource struct {
	SecretName string `json:"secretName,omitempty"`
}

type NFSVolumeSource struct {
	Server   string `json:"server"`

	Path     string `json:"path"`

	ReadOnly bool `json:"readOnly,omitempty"`
}

type ISCSIVolumeSource struct {
	TargetPortal   string `json:"targetPortal"`
	IQN            string `json:"iqn"`
	Lun            int32 `json:"lun"`
	ISCSIInterface string `json:"iscsiInterface,omitempty"`

	FSType         string `json:"fsType,omitempty"`
	ReadOnly       bool `json:"readOnly,omitempty"`
}

type FCVolumeSource struct {
	TargetWWNs []string `json:"targetWWNs"`
	Lun        *int32 `json:"lun"`
	FSType     string `json:"fsType,omitempty"`
	ReadOnly   bool `json:"readOnly,omitempty"`
}

type AzureFileVolumeSource struct {
	SecretName string `json:"secretName"`
	ShareName  string `json:"shareName"`
	ReadOnly   bool `json:"readOnly,omitempty"`
}

type ConfigMapVolumeSource struct {
	LocalObjectReference `json:",inline"`
	Items []KeyToPath `json:"items,omitempty"`
}

type KeyToPath struct {
	Key  string `json:"key"`

	Path string `json:"path"`
}

type ContainerPort struct {
	Name          string `json:"name,omitempty"`
	HostPort      int32 `json:"hostPort,omitempty"`
	ContainerPort int32 `json:"containerPort"`
	Protocol      Protocol `json:"protocol,omitempty"`
	HostIP        string `json:"hostIP,omitempty"`
}

type VolumeMount struct {
	Name      string `json:"name"`
	ReadOnly  bool `json:"readOnly,omitempty"`
	MountPath string `json:"mountPath"`
}

type EnvVar struct {
	Name      string `json:"name"`
	Value     string `json:"value,omitempty"`
	ValueFrom *EnvVarSource `json:"valueFrom,omitempty"`
}

type EnvVarSource struct {
	FieldRef        *ObjectFieldSelector `json:"fieldRef,omitempty"`
	ConfigMapKeyRef *ConfigMapKeySelector `json:"configMapKeyRef,omitempty"`
	SecretKeyRef    *SecretKeySelector `json:"secretKeyRef,omitempty"`
}

type ObjectFieldSelector struct {
	APIVersion string `json:"apiVersion,omitempty"`
	FieldPath  string `json:"fieldPath"`
}

type ConfigMapKeySelector struct {
	LocalObjectReference `json:",inline"`
	Key string `json:"key"`
}

type SecretKeySelector struct {
	LocalObjectReference `json:",inline"`
	Key string `json:"key"`
}

type HTTPHeader struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}
type IntOrString struct {
	Type   int
	IntVal int32
	StrVal string
}

type HTTPGetAction struct {
	Path        string `json:"path,omitempty"`
	Port        IntOrString `json:"port"`
	Host        string `json:"host,omitempty"`
	Scheme      URIScheme `json:"scheme,omitempty"`
	HTTPHeaders []HTTPHeader `json:"httpHeaders,omitempty"`
}

type URIScheme string

const (
	URISchemeHTTP URIScheme = "HTTP"
	URISchemeHTTPS URIScheme = "HTTPS"
)

type TCPSocketAction struct {
	Port IntOrString `json:"port"`
}

type ExecAction struct {
	Command []string `json:"command,omitempty"`
}

type Probe struct {
	Handler `json:",inline"`
	InitialDelaySeconds int32 `json:"initialDelaySeconds,omitempty"`
	TimeoutSeconds      int32 `json:"timeoutSeconds,omitempty"`
	PeriodSeconds       int32 `json:"periodSeconds,omitempty"`
	SuccessThreshold    int32 `json:"successThreshold,omitempty"`
	FailureThreshold    int32 `json:"failureThreshold,omitempty"`
}

type PullPolicy string

const (
	PullAlways PullPolicy = "Always"
	PullNever PullPolicy = "Never"
	PullIfNotPresent PullPolicy = "IfNotPresent"
)

type Capability string

type Capabilities struct {
	Add  []Capability `json:"add,omitempty"`

	Drop []Capability `json:"drop,omitempty"`
}

type ResourceRequirements struct {
	Limits   ResourceList `json:"limits,omitempty"`
	Requests ResourceList `json:"requests,omitempty"`
}

const (
	TerminationMessagePathDefault string = "/dev/termination-log"
)

type Container struct {
	Name                   string `json:"name"`
	Image                  string `json:"image,omitempty"`
	Command                []string `json:"command,omitempty"`
	Args                   []string `json:"args,omitempty"`
	WorkingDir             string `json:"workingDir,omitempty"`
	Ports                  []ContainerPort `json:"ports,omitempty" patchStrategy:"merge" patchMergeKey:"containerPort"`
	Env                    []EnvVar `json:"env,omitempty" patchStrategy:"merge" patchMergeKey:"name"`
	Resources              ResourceRequirements `json:"resources,omitempty"`
	VolumeMounts           []VolumeMount `json:"volumeMounts,omitempty" patchStrategy:"merge" patchMergeKey:"name"`
	LivenessProbe          *Probe `json:"livenessProbe,omitempty"`
	ReadinessProbe         *Probe `json:"readinessProbe,omitempty"`
	Lifecycle              *Lifecycle `json:"lifecycle,omitempty"`
	TerminationMessagePath string `json:"terminationMessagePath,omitempty"`
	ImagePullPolicy        PullPolicy `json:"imagePullPolicy,omitempty"`
	SecurityContext        *SecurityContext `json:"securityContext,omitempty"`
	Stdin                  bool `json:"stdin,omitempty"`
	StdinOnce              bool `json:"stdinOnce,omitempty"`
	TTY                    bool `json:"tty,omitempty"`
}

type Handler struct {
	Exec      *ExecAction `json:"exec,omitempty"`
	HTTPGet   *HTTPGetAction `json:"httpGet,omitempty"`
	TCPSocket *TCPSocketAction `json:"tcpSocket,omitempty"`
}

type Lifecycle struct {
	PostStart *Handler `json:"postStart,omitempty"`
	PreStop   *Handler `json:"preStop,omitempty"`
}

type ConditionStatus string

const (
	ConditionTrue ConditionStatus = "True"
	ConditionFalse ConditionStatus = "False"
	ConditionUnknown ConditionStatus = "Unknown"
)

type ContainerStateWaiting struct {
	Reason  string `json:"reason,omitempty"`
	Message string `json:"message,omitempty"`
}

type ContainerStateRunning struct {
	StartedAt string `json:"startedAt,omitempty"`
}

type ContainerStateTerminated struct {
	ExitCode    int32 `json:"exitCode"`
	Signal      int32 `json:"signal,omitempty"`
	Reason      string `json:"reason,omitempty"`
	Message     string `json:"message,omitempty"`
	StartedAt   string `json:"startedAt,omitempty"`
	FinishedAt  string `json:"finishedAt,omitempty"`
	ContainerID string `json:"containerID,omitempty"`
}

type ContainerState struct {
	Waiting    *ContainerStateWaiting `json:"waiting,omitempty"`
	Running    *ContainerStateRunning `json:"running,omitempty"`
	Terminated *ContainerStateTerminated `json:"terminated,omitempty"`
}

type ContainerStatus struct {
	Name                 string `json:"name"`
	State                ContainerState `json:"state,omitempty"`
	LastTerminationState ContainerState `json:"lastState,omitempty"`
	Ready                bool `json:"ready"`
	RestartCount         int32 `json:"restartCount"`
	Image                string `json:"image"`
	ImageID              string `json:"imageID"`
	ContainerID          string `json:"containerID,omitempty"`
}

type PodPhase string

const (
	PodPending PodPhase = "Pending"
	PodRunning PodPhase = "Running"
	PodSucceeded PodPhase = "Succeeded"
	PodFailed PodPhase = "Failed"
	PodUnknown PodPhase = "Unknown"
)

type PodConditionType string

const (
	PodReady PodConditionType = "Ready"
)

type PodCondition struct {
	Type               PodConditionType `json:"type"`
	Status             ConditionStatus `json:"status"`
	LastProbeTime      Time `json:"lastProbeTime,omitempty"`
	LastTransitionTime string `json:"lastTransitionTime,omitempty"`
	Reason             string `json:"reason,omitempty"`
	Message            string `json:"message,omitempty"`
}

type RestartPolicy string

const (
	RestartPolicyAlways RestartPolicy = "Always"
	RestartPolicyOnFailure RestartPolicy = "OnFailure"
	RestartPolicyNever RestartPolicy = "Never"
)

type DNSPolicy string

const (
	DNSClusterFirst DNSPolicy = "ClusterFirst"

	DNSDefault DNSPolicy = "Default"

	DefaultTerminationGracePeriodSeconds = 30
)

type NodeSelector struct {
	NodeSelectorTerms []NodeSelectorTerm `json:"nodeSelectorTerms"`
}

type NodeSelectorTerm struct {
	MatchExpressions []NodeSelectorRequirement `json:"matchExpressions"`
}

type NodeSelectorRequirement struct {
	Key      string `json:"key" patchStrategy:"merge" patchMergeKey:"key"`
	Operator NodeSelectorOperator `json:"operator"`
	Values   []string `json:"values,omitempty"`
}

type NodeSelectorOperator string

const (
	NodeSelectorOpIn NodeSelectorOperator = "In"
	NodeSelectorOpNotIn NodeSelectorOperator = "NotIn"
	NodeSelectorOpExists NodeSelectorOperator = "Exists"
	NodeSelectorOpDoesNotExist NodeSelectorOperator = "DoesNotExist"
	NodeSelectorOpGt NodeSelectorOperator = "Gt"
	NodeSelectorOpLt NodeSelectorOperator = "Lt"
)

type Affinity struct {
	NodeAffinity *NodeAffinity `json:"nodeAffinity,omitempty"`
}

type NodeAffinity struct {
	RequiredDuringSchedulingIgnoredDuringExecution  *NodeSelector `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
	PreferredDuringSchedulingIgnoredDuringExecution []PreferredSchedulingTerm `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type PreferredSchedulingTerm struct {
	Weight     int `json:"weight"`
	Preference NodeSelectorTerm `json:"preference"`
}

type PodSpec struct {
	Volumes                       []Volume `json:"volumes,omitempty" patchStrategy:"merge" patchMergeKey:"name"`
	Containers                    []Container `json:"containers" patchStrategy:"merge" patchMergeKey:"name"`
	RestartPolicy                 RestartPolicy `json:"restartPolicy,omitempty"`
	TerminationGracePeriodSeconds *int64 `json:"terminationGracePeriodSeconds,omitempty"`
	ActiveDeadlineSeconds         *int64 `json:"activeDeadlineSeconds,omitempty"`
	DNSPolicy                     DNSPolicy `json:"dnsPolicy,omitempty"`
	NodeSelector                  map[string]string `json:"nodeSelector,omitempty"`
	ServiceAccountName            string `json:"serviceAccountName,omitempty"`
	DeprecatedServiceAccount      string `json:"serviceAccount,omitempty"`
	NodeName                      string `json:"nodeName,omitempty"`
	HostNetwork                   bool `json:"hostNetwork,omitempty"`
	HostPID                       bool `json:"hostPID,omitempty"`
	HostIPC                       bool `json:"hostIPC,omitempty"`
	SecurityContext               *PodSecurityContext `json:"securityContext,omitempty"`
	ImagePullSecrets              []LocalObjectReference `json:"imagePullSecrets,omitempty" patchStrategy:"merge" patchMergeKey:"name"`
}

type PodSecurityContext struct {
	SELinuxOptions     *SELinuxOptions `json:"seLinuxOptions,omitempty"`
	RunAsUser          *int64 `json:"runAsUser,omitempty"`
	RunAsNonRoot       *bool `json:"runAsNonRoot,omitempty"`
	SupplementalGroups []int64 `json:"supplementalGroups,omitempty"`
	FSGroup            *int64 `json:"fsGroup,omitempty"`
}

type PodStatus struct {
	Phase             PodPhase `json:"phase,omitempty"`
	Conditions        []PodCondition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type"`
	Message           string `json:"message,omitempty"`
	Reason            string `json:"reason,omitempty"`

	HostIP            string `json:"hostIP,omitempty"`
	PodIP             string `json:"podIP,omitempty"`

	StartTime         *string `json:"startTime,omitempty"`
	ContainerStatuses []ContainerStatus `json:"containerStatuses,omitempty"`
}

type PodStatusResult struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`
	Status PodStatus `json:"status,omitempty"`
}

type Pod struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Spec   PodSpec `json:"spec,omitempty"`

	Status PodStatus `json:"status,omitempty"`
}

type PodList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []Pod `json:"items"`
}

type PodTemplateSpec struct {
	ObjectMeta `json:"metadata,omitempty"`

	Spec PodSpec `json:"spec,omitempty"`
}

type PodTemplate struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Template PodTemplateSpec `json:"template,omitempty"`
}

type PodTemplateList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []PodTemplate `json:"items"`
}

type ReplicationControllerSpec struct {
	Replicas *int32 `json:"replicas,omitempty"`
	Selector map[string]string `json:"selector,omitempty"`
	Template *PodTemplateSpec `json:"template,omitempty"`
}

type ReplicationControllerStatus struct {
	Replicas           int32 `json:"replicas"`

	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
}

type ReplicationController struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Spec   ReplicationControllerSpec `json:"spec,omitempty"`

	Status ReplicationControllerStatus `json:"status,omitempty"`
}

type ReplicationControllerList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []ReplicationController `json:"items"`
}

type ServiceAffinity string

const (
	ServiceAffinityClientIP ServiceAffinity = "ClientIP"

	ServiceAffinityNone ServiceAffinity = "None"
)

type ServiceType string

const (
	ServiceTypeClusterIP ServiceType = "ClusterIP"

	ServiceTypeNodePort ServiceType = "NodePort"

	ServiceTypeLoadBalancer ServiceType = "LoadBalancer"
)

type ServiceStatus struct {
	LoadBalancer LoadBalancerStatus `json:"loadBalancer,omitempty"`
}

type LoadBalancerStatus struct {
	Ingress []LoadBalancerIngress `json:"ingress,omitempty"`
}

type LoadBalancerIngress struct {
	IP       string `json:"ip,omitempty"`

	Hostname string `json:"hostname,omitempty"`
}

type ServiceSpec struct {
	Ports               []ServicePort `json:"ports"`

	Selector            map[string]string `json:"selector,omitempty"`

	ClusterIP           string `json:"clusterIP,omitempty"`

	Type                ServiceType `json:"type,omitempty"`

	ExternalIPs         []string `json:"externalIPs,omitempty"`

	DeprecatedPublicIPs []string `json:"deprecatedPublicIPs,omitempty"`

	SessionAffinity     ServiceAffinity `json:"sessionAffinity,omitempty"`

	LoadBalancerIP      string `json:"loadBalancerIP,omitempty"`
}

type ServicePort struct {
	Name       string `json:"name,omitempty"`

	Protocol   Protocol `json:"protocol,omitempty"`

	Port       int32 `json:"port"`

	TargetPort int `json:"targetPort,omitempty"` //IntOrString

	NodePort   int32 `json:"nodePort,omitempty"`
}

type Service struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Spec   ServiceSpec `json:"spec,omitempty"`

	Status ServiceStatus `json:"status,omitempty"`
}

const (
	ClusterIPNone = "None"
)

type ServiceList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []Service `json:"items"`
}

type ServiceAccount struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Secrets          []ObjectReference `json:"secrets,omitempty" patchStrategy:"merge" patchMergeKey:"name"`

	ImagePullSecrets []LocalObjectReference `json:"imagePullSecrets,omitempty"`
}

type ServiceAccountList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []ServiceAccount `json:"items"`
}

type Endpoints struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Subsets []EndpointSubset `json:"subsets"`
}

type EndpointSubset struct {
	Addresses         []EndpointAddress `json:"addresses,omitempty"`
	NotReadyAddresses []EndpointAddress `json:"notReadyAddresses,omitempty"`
	Ports             []EndpointPort `json:"ports,omitempty"`
}

type EndpointAddress struct {
	IP        string `json:"ip"`

	TargetRef *ObjectReference `json:"targetRef,omitempty"`
}

type EndpointPort struct {
	Name     string `json:"name,omitempty"`

	Port     int32 `json:"port"`

	Protocol Protocol `json:"protocol,omitempty"`
}

type EndpointsList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []Endpoints `json:"items"`
}

type NodeSpec struct {
	PodCIDR       string `json:"podCIDR,omitempty"`
	ExternalID    string `json:"externalID,omitempty"`
	ProviderID    string `json:"providerID,omitempty"`
	Unschedulable bool `json:"unschedulable,omitempty"`
}

type DaemonEndpoint struct {
	Port int32 `json:port`
}

type NodeDaemonEndpoints struct {
	KubeletEndpoint DaemonEndpoint `json:"kubeletEndpoint,omitempty"`
}

type NodeSystemInfo struct {
	MachineID               string `json:"machineID"`
	SystemUUID              string `json:"systemUUID"`
	BootID                  string `json:"bootID"`
	KernelVersion           string `json:"kernelVersion"`
	OSImage                 string `json:"osImage"`
	ContainerRuntimeVersion string `json:"containerRuntimeVersion"`
	KubeletVersion          string `json:"kubeletVersion"`
	KubeProxyVersion        string `json:"kubeProxyVersion"`
}

type NodeStatus struct {
	Capacity        ResourceList `json:"capacity,omitempty"`
	Allocatable     ResourceList `json:"allocatable,omitempty"`
	Phase           NodePhase `json:"phase,omitempty"`
	Conditions      []NodeCondition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type"`
	Addresses       []NodeAddress `json:"addresses,omitempty" patchStrategy:"merge" patchMergeKey:"type"`
	DaemonEndpoints NodeDaemonEndpoints `json:"daemonEndpoints,omitempty"`
	NodeInfo        NodeSystemInfo `json:"nodeInfo,omitempty"`
	Images          []ContainerImage `json:"images",omitempty`
}

type ContainerImage struct {
	Names     []string `json:"names"`
	SizeBytes int64 `json:"sizeBytes,omitempty"`
}

type NodePhase string

const (
	NodePending NodePhase = "Pending"
	NodeRunning NodePhase = "Running"
	NodeTerminated NodePhase = "Terminated"
)

type NodeConditionType string

const (
	NodeReady NodeConditionType = "Ready"
	NodeOutOfDisk NodeConditionType = "OutOfDisk"
)

type NodeCondition struct {
	Type               NodeConditionType `json:"type"`
	Status             ConditionStatus `json:"status"`
	LastHeartbeatTime  string `json:"lastHeartbeatTime,omitempty"`
	LastTransitionTime string `json:"lastTransitionTime,omitempty"`
	Reason             string `json:"reason,omitempty"`
	Message            string `json:"message,omitempty"`
}

type NodeAddressType string

const (
	NodeHostName NodeAddressType = "Hostname"
	NodeExternalIP NodeAddressType = "ExternalIP"
	NodeInternalIP NodeAddressType = "InternalIP"
)

type NodeAddress struct {
	Type    NodeAddressType `json:"type"`
	Address string `json:"address"`
}

type ResourceName string

const (
	ResourceCPU ResourceName = "cpu"
	ResourceMemory ResourceName = "memory"
	ResourceStorage ResourceName = "storage"
)

type Quantity struct {
	Amount *inf.Dec

	string
}

type ResourceList map[ResourceName]string

type Node struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Spec   NodeSpec `json:"spec,omitempty"`

	Status NodeStatus `json:"status,omitempty"`
}

func PrintJob(job Job) {
	fmt.Println("Job Message:")
	fmt.Println("Job Object: ", job.ObjectMeta)
	fmt.Println("Job TypeMeta:", job.TypeMeta)
	fmt.Println("Job Spec:", job.Spec)
	fmt.Println("Job Status", job.Status)
}

func PrintReplicationController(replicationcontroller ReplicationController) {
	fmt.Print("Replicationcontroller Message:\n")
	fmt.Print("ReplicationcontrollerName: " + replicationcontroller.Name + "\n")
	fmt.Print("Namespace: " + replicationcontroller.Namespace + "\n")
	fmt.Print("Kind: " + replicationcontroller.TypeMeta.APIVersion + "\n")
	fmt.Print("APIVersion: " + replicationcontroller.TypeMeta.Kind + "\n")
	fmt.Print("CreationTimestamp: " + replicationcontroller.CreationTimestamp + "\n")
	fmt.Print("Labels: ")
	fmt.Print(replicationcontroller.Labels)
	fmt.Print("\n")
	fmt.Print("Spec: ")
	fmt.Print(replicationcontroller.Spec)
	fmt.Print("\n")
	fmt.Print("Status: ")
	fmt.Print(replicationcontroller.Status)
	fmt.Print("\n")
}

func PrintService(service Service) {
	fmt.Print("Service Message:\n")
	fmt.Print("ServiceName: " + service.Name + "\n")
	fmt.Print("Namespace: " + service.Namespace + "\n")
	fmt.Print("Kind: " + service.TypeMeta.APIVersion + "\n")
	fmt.Print("APIVersion: " + service.TypeMeta.Kind + "\n")
	fmt.Print("CreationTimestamp: " + service.CreationTimestamp + "\n")
	fmt.Print("Labels: ")
	fmt.Print(service.Labels)
	fmt.Print("\n")
	fmt.Print("Spec: ")
	fmt.Print(service.Spec)
	fmt.Print("\n")
	fmt.Print("Status: ")
	fmt.Print(service.Status)
	fmt.Print("\n")
}

func PrintNode(node Node) {
	fmt.Print("Node Message:\n")
	fmt.Print("NodeName: " + node.Name + "\n")
	fmt.Print("Namespace: " + node.Namespace + "\n")
	fmt.Print("Kind: " + node.TypeMeta.APIVersion + "\n")
	fmt.Print("APIVersion: " + node.TypeMeta.Kind + "\n")
	fmt.Print("CreationTimestamp: " + node.CreationTimestamp + "\n")
	fmt.Print("Labels: ")
	fmt.Print(node.Labels)
	fmt.Print("\n")
	fmt.Print("Spec: ")
	fmt.Print(node.Spec)
	fmt.Print("\n")
	fmt.Print("Status: ")
	fmt.Print(node.Status)
	fmt.Print("\n")
}
func PrintNamespace(namespace Namespace) {
	fmt.Print("Namespace Message:\n")
	fmt.Print("Name: " + namespace.Name + "\n")
	fmt.Print("CreationTimestamp: " + namespace.CreationTimestamp + "\n")
	fmt.Print("Labels: ")
	fmt.Print(namespace.Labels)
	fmt.Print("\n")
	fmt.Print("Spec: ")
	fmt.Print(namespace.Spec)
	fmt.Print("\n")
	fmt.Print("Status: ")
	fmt.Print(namespace.Status)
	fmt.Print("\n")
	fmt.Print("ObjectMeta: ")
	fmt.Print(namespace.ObjectMeta)
	fmt.Print("\n")
}
func PrintPod(pod Pod) {
	fmt.Print("Pod Message:\n")
	fmt.Print("Name: " + pod.Name + "\n")
	fmt.Print("CreationTimestamp: " + pod.CreationTimestamp + "\n")
	fmt.Print("spec: ")
	fmt.Print(pod.Spec)
	fmt.Print("\n")
	fmt.Print("ObjectMeta: ")
	fmt.Print(pod.ObjectMeta)
	fmt.Print("\n")
	fmt.Print("Status: ")
	fmt.Print(pod.Status)
	fmt.Print("\n")
	fmt.Print("Labels: ")
	fmt.Print(pod.Labels)
	fmt.Print("\n")
}

type NodeList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []Node `json:"items"`
}

type FinalizerName string

const (
	FinalizerKubernetes FinalizerName = "kubernetes"
)

type NamespaceSpec struct {
	Finalizers []FinalizerName `json:"finalizers,omitempty"`
}

type NamespaceStatus struct {
	Phase NamespacePhase `json:"phase,omitempty"`
}

type NamespacePhase string

const (
	NamespaceActive NamespacePhase = "Active"
	NamespaceTerminating NamespacePhase = "Terminating"
)

type Namespace struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Spec   NamespaceSpec `json:"spec,omitempty"`

	Status NamespaceStatus `json:"status,omitempty"`
}

type NamespaceList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []Namespace `json:"items"`
}

type Binding struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Target ObjectReference `json:"target"`
}

type DeleteOptions struct {
	TypeMeta `json:",inline"`
	GracePeriodSeconds *int64 `json:"gracePeriodSeconds"`
}

type ExportOptions struct {
	TypeMeta `json:",inline"`

	Export bool `json:"export"`
	Exact  bool `json:"exact"`
}

type ListOptions struct {
	TypeMeta `json:",inline"`

	LabelSelector   string `json:"labelSelector,omitempty"`
	FieldSelector   string `json:"fieldSelector,omitempty"`
	Watch           bool `json:"watch,omitempty"`
	ResourceVersion string `json:"resourceVersion,omitempty"`
	TimeoutSeconds  *int64 `json:"timeoutSeconds,omitempty"`
}

type PodLogOptions struct {
	TypeMeta `json:",inline"`

	Container    string `json:"container,omitempty"`
	Follow       bool `json:"follow,omitempty"`
	Previous     bool `json:"previous,omitempty"`
	SinceSeconds *int64 `json:"sinceSeconds,omitempty"`
	SinceTime    *Time `json:"sinceTime,omitempty"`
	Timestamps   bool `json:"timestamps,omitempty"`
	TailLines    *int64 `json:"tailLines,omitempty"`
	LimitBytes   *int64 `json:"limitBytes,omitempty"`
}

type PodAttachOptions struct {
	TypeMeta `json:",inline"`

	Stdin     bool `json:"stdin,omitempty"`

	Stdout    bool `json:"stdout,omitempty"`

	Stderr    bool `json:"stderr,omitempty"`

	TTY       bool `json:"tty,omitempty"`

	Container string `json:"container,omitempty"`
}

type PodExecOptions struct {
	TypeMeta `json:",inline"`

	Stdin     bool `json:"stdin,omitempty"`

	Stdout    bool `json:"stdout,omitempty"`

	Stderr    bool `json:"stderr,omitempty"`

	TTY       bool `json:"tty,omitempty"`

	Container string `json:"container,omitempty"`

	Command   []string `json:"command"`
}

type PodProxyOptions struct {
	TypeMeta `json:",inline"`

	Path string `json:"path,omitempty"`
}

type NodeProxyOptions struct {
	TypeMeta `json:",inline"`

	Path string `json:"path,omitempty"`
}

type ServiceProxyOptions struct {
	TypeMeta `json:",inline"`

	Path string `json:"path,omitempty"`
}

type ObjectReference struct {
	Kind            string `json:"kind,omitempty"`
	Namespace       string `json:"namespace,omitempty"`
	Name            string `json:"name,omitempty"`
	UID             string `json:"uid,omitempty"`
	APIVersion      string `json:"apiVersion,omitempty"`
	ResourceVersion string `json:"resourceVersion,omitempty"`

	FieldPath       string `json:"fieldPath,omitempty"`
}

type LocalObjectReference struct {
	Name string `json:"name,omitempty"`
}

type SerializedReference struct {
	TypeMeta `json:",inline"`
	Reference ObjectReference `json:"reference,omitempty"`
}

type EventSource struct {
	Component string `json:"component,omitempty"`
	Host      string `json:"host,omitempty"`
}

const (
	EventTypeNormal string = "Normal"
	EventTypeWarning string = "Warning"
)

type Event struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata"`

	InvolvedObject ObjectReference `json:"involvedObject"`

	Reason         string `json:"reason,omitempty"`

	Message        string `json:"message,omitempty"`

	Source         EventSource `json:"source,omitempty"`

	FirstTimestamp Time `json:"firstTimestamp,omitempty"`

	LastTimestamp  Time `json:"lastTimestamp,omitempty"`

	Count          int32 `json:"count,omitempty"`

	Type           string `json:"type,omitempty"`
}

type EventList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []Event `json:"items"`
}

type GroupVersionKind struct {
	Group   string
	Version string
	Kind    string
}
type ObjectKind interface {
	SetGroupVersionKind(kind *GroupVersionKind)
	GroupVersionKind() *GroupVersionKind
}
type Object interface {
	GetObjectKind() ObjectKind
}
type RawExtension struct {
	RawJSON []byte
	Object  Object `json:"-"`
}

type List struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []RawExtension `json:"items"`
}

type LimitType string

const (
	LimitTypePod LimitType = "Pod"
	LimitTypeContainer LimitType = "Container"
)

type LimitRangeItem struct {
	Type                 LimitType `json:"type,omitempty"`
	Max                  ResourceList `json:"max,omitempty"`
	Min                  ResourceList `json:"min,omitempty"`
	Default              ResourceList `json:"default,omitempty"`
	DefaultRequest       ResourceList `json:"defaultRequest,omitempty"`
	MaxLimitRequestRatio ResourceList `json:"maxLimitRequestRatio,omitempty"`
}

type LimitRangeSpec struct {
	Limits []LimitRangeItem `json:"limits"`
}

type LimitRange struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Spec LimitRangeSpec `json:"spec,omitempty"`
}

type LimitRangeList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []LimitRange `json:"items"`
}

const (
	ResourcePods ResourceName = "pods"
	ResourceServices ResourceName = "services"
	ResourceReplicationControllers ResourceName = "replicationcontrollers"
	ResourceQuotas ResourceName = "resourcequotas"
	ResourceSecrets ResourceName = "secrets"
	ResourceConfigMaps ResourceName = "configmaps"
	ResourcePersistentVolumeClaims ResourceName = "persistentvolumeclaims"
	ResourceCPURequest ResourceName = "cpu.request"
	ResourceCPULimit ResourceName = "cpu.limit"
	ResourceMemoryRequest ResourceName = "memory.request"
	ResourceMemoryLimit ResourceName = "memory.limit"
)

type ResourceQuotaScope string

const (
	ResourceQuotaScopeTerminating ResourceQuotaScope = "Terminating"
	ResourceQuotaScopeNotTerminating ResourceQuotaScope = "NotTerminating"
	ResourceQuotaScopeBestEffort ResourceQuotaScope = "BestEffort"
	ResourceQuotaScopeNotBestEffort ResourceQuotaScope = "NotBestEffort"
)

type ResourceQuotaSpec struct {
	Hard   ResourceList `json:"hard,omitempty"`
	Scopes []ResourceQuotaScope `json:"scopes,omitempty"`
}

type ResourceQuotaStatus struct {
	Hard ResourceList `json:"hard,omitempty"`
	Used ResourceList `json:"used,omitempty"`
}

type ResourceQuota struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Spec   ResourceQuotaSpec `json:"spec,omitempty"`

	Status ResourceQuotaStatus `json:"status,omitempty"`
}

type ResourceQuotaList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []ResourceQuota `json:"items"`
}

type Secret struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`
	Data map[string][]byte `json:"data,omitempty"`

	Type SecretType `json:"type,omitempty"`
}

const MaxSecretSize = 1 * 1024 * 1024

type SecretType string

const (
	SecretTypeOpaque SecretType = "Opaque"

	SecretTypeServiceAccountToken SecretType = "kubernetes.io/service-account-token"

	ServiceAccountNameKey = "kubernetes.io/service-account.name"
	ServiceAccountUIDKey = "kubernetes.io/service-account.uid"
	ServiceAccountTokenKey = "token"
	ServiceAccountKubeconfigKey = "kubernetes.kubeconfig"
	ServiceAccountRootCAKey = "ca.crt"
	ServiceAccountNamespaceKey = "namespace"

	SecretTypeDockercfg SecretType = "kubernetes.io/dockercfg"

	DockerConfigKey = ".dockercfg"

	SecretTypeTLS SecretType = "kubernetes.io/tls"

	TLSCertKey = "tls.crt"
	TLSPrivateKeyKey = "tls.key"
)

type SecretList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []Secret `json:"items"`
}

type ConfigMap struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Data map[string]string `json:"data,omitempty"`
}

type ConfigMapList struct {
	TypeMeta `json:",inline"`

	ListMeta `json:"metadata,omitempty"`

	Items []ConfigMap `json:"items,omitempty"`
}

type ComponentConditionType string

const (
	ComponentHealthy ComponentConditionType = "Healthy"
)

type ComponentCondition struct {
	Type    ComponentConditionType `json:"type"`
	Status  ConditionStatus `json:"status"`
	Message string `json:"message,omitempty"`
	Error   string `json:"error,omitempty"`
}

type ComponentStatus struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Conditions []ComponentCondition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type"`
}

type ComponentStatusList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []ComponentStatus `json:"items"`
}

type DownwardAPIVolumeSource struct {
	Items []DownwardAPIVolumeFile `json:"items,omitempty"`
}

type DownwardAPIVolumeFile struct {
	Path     string `json:"path"`
	FieldRef ObjectFieldSelector `json:"fieldRef"`
}

type SecurityContext struct {
	Capabilities           *Capabilities `json:"capabilities,omitempty"`
	Privileged             *bool `json:"privileged,omitempty"`
	SELinuxOptions         *SELinuxOptions `json:"seLinuxOptions,omitempty"`
	RunAsUser              *int64 `json:"runAsUser,omitempty"`
	RunAsNonRoot           *bool `json:"runAsNonRoot,omitempty"`
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty"`
}

type SELinuxOptions struct {
	User  string `json:"user,omitempty"`
	Role  string `json:"role,omitempty"`
	Type  string `json:"type,omitempty"`
	Level string `json:"level,omitempty"`
}

type RangeAllocation struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Range string `json:"range"`
	Data  []byte `json:"data"`
}

const (
	DefaultSchedulerName = "default-scheduler"
)


//job 相关
type Job struct {
	TypeMeta `json:",inline"`
	// Standard object's metadata.
	// More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#metadata
	ObjectMeta `json:"metadata,omitempty"`

	// Spec is a structure defining the expected behavior of a job.
	// More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#spec-and-status
	Spec   JobSpec `json:"spec,omitempty"`

	// Status is a structure describing current status of a job.
	// More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#spec-and-status
	Status JobStatus `json:"status,omitempty"`
}

// JobList is a collection of jobs.
type JobList struct {
	TypeMeta `json:",inline"`
	// Standard list metadata
	// More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#metadata
	ListMeta `json:"metadata,omitempty"`

	// Items is the list of Job.
	Items []Job `json:"items"`
}

// JobSpec describes how the job execution will look like.
type JobSpec struct {
	// Parallelism specifies the maximum desired number of pods the job should
	// run at any given time. The actual number of pods running in steady state will
	// be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism),
	// i.e. when the work left to do is less than max parallelism.
	// More info: http://releases.k8s.io/HEAD/docs/user-guide/jobs.md
	Parallelism           *int32 `json:"parallelism,omitempty"`

	// Completions specifies the desired number of successfully finished pods the
	// job should be run with.  Setting to nil means that the success of any
	// pod signals the success of all pods, and allows parallelism to have any positive
	// value.  Setting to 1 means that parallelism is limited to 1 and the success of that
	// pod signals the success of the job.
	// More info: http://releases.k8s.io/HEAD/docs/user-guide/jobs.md
	Completions           *int32 `json:"completions,omitempty"`

	// Optional duration in seconds relative to the startTime that the job may be active
	// before the system tries to terminate it; value must be positive integer
	ActiveDeadlineSeconds *int64 `json:"activeDeadlineSeconds,omitempty"`

	// Selector is a label query over pods that should match the pod count.
	// Normally, the system sets this field for you.
	// More info: http://releases.k8s.io/HEAD/docs/user-guide/labels.md#label-selectors
	Selector              *LabelSelector `json:"selector,omitempty"`

	// ManualSelector controls generation of pod labels and pod selectors.
	// Leave `manualSelector` unset unless you are certain what you are doing.
	// When false or unset, the system pick labels unique to this job
	// and appends those labels to the pod template.  When true,
	// the user is responsible for picking unique labels and specifying
	// the selector.  Failure to pick a unique label may cause this
	// and other jobs to not function correctly.  However, You may see
	// `manualSelector=true` in jobs that were created with the old `extensions/v1beta1`
	// API.
	// More info: http://releases.k8s.io/HEAD/docs/design/selector-generation.md
	ManualSelector        *bool `json:"manualSelector,omitempty"`

	// Template is the object that describes the pod that will be created when
	// executing a job.
	// More info: http://releases.k8s.io/HEAD/docs/user-guide/jobs.md
	Template              PodTemplateSpec `json:"template"`
}

// JobStatus represents the current state of a Job.
type JobStatus struct {
	// Conditions represent the latest available observations of an object's current state.
	// More info: http://releases.k8s.io/HEAD/docs/user-guide/jobs.md
	Conditions     []JobCondition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type"`

	// StartTime represents time when the job was acknowledged by the Job Manager.
	// It is not guaranteed to be set in happens-before order across separate operations.
	// It is represented in RFC3339 form and is in UTC.
	StartTime      string `json:"startTime,omitempty"`

	// CompletionTime represents time when the job was completed. It is not guaranteed to
	// be set in happens-before order across separate operations.
	// It is represented in RFC3339 form and is in UTC.
	CompletionTime *string `json:"completionTime,omitempty"`

	// Active is the number of actively running pods.
	Active         int32 `json:"active,omitempty"`

	// Succeeded is the number of pods which reached Phase Succeeded.
	Succeeded      int32 `json:"succeeded,omitempty"`

	// Failed is the number of pods which reached Phase Failed.
	Failed         int32 `json:"failed,omitempty"`
}

type JobConditionType string

// These are valid conditions of a job.
const (
	// JobComplete means the job has completed its execution.
	JobComplete JobConditionType = "Complete"
	// JobFailed means the job has failed its execution.
	JobFailed JobConditionType = "Failed"
)

// JobCondition describes current state of a job.
type JobCondition struct {
	// Type of job condition, Complete or Failed.
	Type               JobConditionType `json:"type"`
	// Status of the condition, one of True, False, Unknown.
	Status             ConditionStatus `json:"status"`
	// Last time the condition was checked.
	LastProbeTime      Time `json:"lastProbeTime,omitempty"`
	// Last time the condition transit from one status to another.
	LastTransitionTime Time `json:"lastTransitionTime,omitempty"`
	// (brief) reason for the condition's last transition.
	Reason             string `json:"reason,omitempty"`
	// Human readable message indicating details about last transition.
	Message            string `json:"message,omitempty"`
}

// A label selector is a label query over a set of resources. The result of matchLabels and
// matchExpressions are ANDed. An empty label selector matches all objects. A null
// label selector matches no objects.
type LabelSelector struct {
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels      map[string]string `json:"matchLabels,omitempty"`
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []LabelSelectorRequirement `json:"matchExpressions,omitempty"`
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type LabelSelectorRequirement struct {
	// key is the label key that the selector applies to.
	Key      string `json:"key" patchStrategy:"merge" patchMergeKey:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators ard In, NotIn, Exists and DoesNotExist.
	Operator LabelSelectorOperator `json:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values   []string `json:"values,omitempty"`
}

// A label selector operator is the set of operators that can be used in a selector requirement.
type LabelSelectorOperator string

const (
	LabelSelectorOpIn LabelSelectorOperator = "In"
	LabelSelectorOpNotIn LabelSelectorOperator = "NotIn"
	LabelSelectorOpExists LabelSelectorOperator = "Exists"
	LabelSelectorOpDoesNotExist LabelSelectorOperator = "DoesNotExist"
)