package type137

import (
	"gopkg.in/inf.v0"
	"fmt"
	"github.com/wy2745/kubernetes-deployment-tool/interf"
	"strings"
	"encoding/json"
)


//type Metadata struct{
//	Name string `json:"name,omitempty"`
//	GenerateName string `json:"generateName,omitempty"`
//	SelfLink string `json:"selfLink,omitempty"`
//	ResourceVersion string `json:"resourceVersion,omitempty"`
//	Namespace string `json:"namespace,omitempty"`
//	Uid string `json:"uid,omitempty"`
//	Generation int `json:"generation,omitempty"`
//	CreationTimestamp string `json:"CreationTimestamp,omitempty"`
//	DeletionTimestamp string `json:"deletionTimestamp,omitempty"`
//	DeletionGracePeriodSeconds int `json:"deletionGracePeriodSeconds,omitempty"`
//}
//
//
//type Item struct{
//	Kind string `json:"kind,omitempty"`
//	ApiVersion string `json:"apiVersion,omitempty"`
//	Metadata Metadata `json:"metadata,omitempty"`
//	Spec Spec `json:"spec,omitempty"`
//	Status Status `json:"status,omitempty"`
//}
//
//type Spec struct{
//	PodCIDR string `json:"podCIDR,omitempty"`
//	ExternalID string `json:"externalID,omitempty"`
//	ProviderID string `json:"providerID,omitempty"`
//	Unschedulable bool `json:"unschedulable,omitempty"`
//}
//
//type Condition struct{
//	Type string `json:"type,omitempty"`
//	Status string `json:"status,omitempty"`
//	LastHeartbeatTime string `json:"LastHeartbeatTime,omitempty"`
//	LastTransitionTime string `json:"lastTransitionTime,omitempty"`
//	Reason string `json:"reason,omitempty"`
//	Message string `json:"message,omitempty"`
//}
//type Status struct{
//	Phase string `json:"phase,omitempty"`
//	Conditions []Condition `json:"conditions,omitempty"`
//	Addresses []Address `json:"addresses,omitempty"`
//}
//type Address struct{
//	Type string `json:"type,omitempty"`
//	Address string `json:"address,omitempty"`
//}
//
//type KubectlEndpoint struct{
//	Port int `json:"Port,omitempty"`
//}
//type DaemonEndpoints struct{
//	KubeletEndpoints KubectlEndpoint `json:"kubeletEndpoint,omitempty"`
//}
//type NodeInfo struct{
//	MachineID string `json:"machineID,omitempty"`
//	SystemUUID string `json:"systemUUID,omitempty"`
//	BootID string `json:"bootID,omitempty"`
//	KernelVersion string `json:"kernelVersion,omitempty"`
//	OsImage string `json:"osImage,omitempty"`
//	ContainerRuntimeVersion string `json:"containerRuntimeVersion,omitempty"`
//	KubeletVersion string `json:"kubeletVersion,omitempty"`
//	KubeProxyVersion string `json:"kubeProxyVersion,omitempty"`
//}
//
//
//
//type Node struct{
//
//	Kind  string `json:"kind,omitempty"`
//	ApiVersion  string `json:"apiVersion,omitempty"`
//	Metadata Metadata `json:"metadata,omitempty"`
//	Items []Item `json:"items,omitempty"`
//	DaemonEndpoints DaemonEndpoints `json:"daemonEndpoints,omitempty"`
//	NodeInfo NodeInfo `json:"nodeInfo,omitempty"`
//}


type zone struct {
	name   string
	offset int
	isDST  bool
}

type zoneTrans struct {
	when         int64
	index        uint8
	isstd, isutc bool
}
type Location struct {
	name       string
	zone       []zone
	tx         []zoneTrans

	// Most lookups will be for the current time.
	// To avoid the binary search through tx, keep a
	// static one-element cache that gives the correct
	// zone for the time when the Location was created.
	// if cacheStart <= t <= cacheEnd,
	// lookup can return cacheZone.
	// The units for cacheStart and cacheEnd are seconds
	// since January 1, 1970 UTC, to match the argument
	// to lookup.
	cacheStart int64
	cacheEnd   int64
	cacheZone  *zone
}
type Time struct {
	// sec gives the number of seconds elapsed since
	// January 1, year 1 00:00:00 UTC.
	sec  int64

	// nsec specifies a non-negative nanosecond
	// offset within the second named by Seconds.
	// It must be in the range [0, 999999999].
	nsec int32

	// loc specifies the Location that should be used to
	// determine the minute, hour, month, day, and year
	// that correspond to this Time.
	// Only the zero Time has a nil Location.
	// In that case it is interpreted to mean UTC.
	loc  *Location
}


// The comments for the structs and fields can be used from go-resful to
// generate Swagger API documentation for its models. Please read this PR for more
// information on the implementation: https://github.com/emicklei/go-restful/pull/215
//
// TODOs are ignored from the parser (e.g. TODO(andronat):... || TODO:...) if and only if
// they are on one line! For multiple line or blocks that you want to ignore use ---.
// Any context after a --- is ignored and not exported to the SwaggerAPI.
//
// The aforementioned methods can be generated by hack/update-generated-swagger-docs.sh

// Common string formats
// ---------------------
// Many fields in this API have formatting requirements. The commonly used
// formats are defined here.
//
// C_IDENTIFIER:  This is a string that conforms to the definition of an "identifier"
//     in the C language. This is captured by the following regex:
//         [A-Za-z_][A-Za-z0-9_]*
//     This defines the format, but not the length restriction, which should be
//     specified at the definition of any field of this type.
//
// DNS_LABEL:  This is a string, no more than 63 characters long, that conforms
//     to the definition of a "label" in RFCs 1035 and 1123. This is captured
//     by the following regex:
//         [a-z0-9]([-a-z0-9]*[a-z0-9])?
//
// DNS_SUBDOMAIN:  This is a string, no more than 253 characters long, that conforms
//      to the definition of a "subdomain" in RFCs 1035 and 1123. This is captured
//      by the following regex:
//         [a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*
//     or more simply:
//         DNS_LABEL(\.DNS_LABEL)*
//
// IANA_SVC_NAME: This is a string, no more than 15 characters long, that
//      conforms to the definition of IANA service name in RFC 6335.
//      It must contains at least one letter [a-z] and it must contains only [a-z0-9-].
//      Hypens ('-') cannot be leading or trailing character of the string
//      and cannot be adjacent to other hyphens.

// ObjectMeta is metadata that all persisted resources must have, which includes all objects
// users must create.
type ObjectMeta struct {
	Name                       string `json:"name,omitempty"`

	GenerateName               string `json:"generateName,omitempty"`

	Namespace                  string `json:"namespace,omitempty"`

	SelfLink                   string `json:"selfLink,omitempty"`

	UID                        string `json:"uid,omitempty"`

	ResourceVersion            string `json:"resourceVersion,omitempty"`

	Generation                 int64 `json:"generation,omitempty"`

	CreationTimestamp          string `json:"creationTimestamp,omitempty"`

	DeletionTimestamp          *Time `json:"deletionTimestamp,omitempty"`

	DeletionGracePeriodSeconds *int64 `json:"deletionGracePeriodSeconds,omitempty"`

	Labels                     map[string]string `json:"labels,omitempty"`

	Annotations                map[string]string `json:"annotations,omitempty"`
}

func (om ObjectMeta) SetOmProp(labelname string, namespace string, name string) {
	om.Labels = make(map[string]string)
	om.Labels["name"] = name
	om.Namespace = namespace
	om.Name = name
}

const (
	NamespaceDefault string = "default"
	NamespaceAll string = ""
)

type Volume struct {
	Name string `json:"name"`

	VolumeSource `json:",inline"`
}

type VolumeSource struct {
	HostPath              *HostPathVolumeSource `json:"hostPath,omitempty"`

	EmptyDir              *EmptyDirVolumeSource `json:"emptyDir,omitempty"`

	GCEPersistentDisk     *GCEPersistentDiskVolumeSource `json:"gcePersistentDisk,omitempty"`

	AWSElasticBlockStore  *AWSElasticBlockStoreVolumeSource `json:"awsElasticBlockStore,omitempty"`

	GitRepo               *GitRepoVolumeSource `json:"gitRepo,omitempty"`

	Secret                *SecretVolumeSource `json:"secret,omitempty"`

	NFS                   *NFSVolumeSource `json:"nfs,omitempty"`

	ISCSI                 *ISCSIVolumeSource `json:"iscsi,omitempty"`

	Glusterfs             *GlusterfsVolumeSource `json:"glusterfs,omitempty"`

	PersistentVolumeClaim *PersistentVolumeClaimVolumeSource `json:"persistentVolumeClaim,omitempty"`

	RBD                   *RBDVolumeSource `json:"rbd,omitempty"`

	FlexVolume            *FlexVolumeSource `json:"flexVolume,omitempty"`

	Cinder                *CinderVolumeSource `json:"cinder,omitempty"`

	CephFS                *CephFSVolumeSource `json:"cephfs,omitempty"`

	Flocker               *FlockerVolumeSource `json:"flocker,omitempty"`

	DownwardAPI           *DownwardAPIVolumeSource `json:"downwardAPI,omitempty"`
	FC                    *FCVolumeSource `json:"fc,omitempty"`
	AzureFile             *AzureFileVolumeSource `json:"azureFile,omitempty"`
	ConfigMap             *ConfigMapVolumeSource `json:"configMap,omitempty"`
}

type PersistentVolumeClaimVolumeSource struct {
	ClaimName string `json:"claimName"`

	ReadOnly  bool `json:"readOnly,omitempty"`
}

type PersistentVolumeSource struct {
	GCEPersistentDisk    *GCEPersistentDiskVolumeSource `json:"gcePersistentDisk,omitempty"`

	AWSElasticBlockStore *AWSElasticBlockStoreVolumeSource `json:"awsElasticBlockStore,omitempty"`

	HostPath             *HostPathVolumeSource `json:"hostPath,omitempty"`

	Glusterfs            *GlusterfsVolumeSource `json:"glusterfs,omitempty"`

	NFS                  *NFSVolumeSource `json:"nfs,omitempty"`

	RBD                  *RBDVolumeSource `json:"rbd,omitempty"`

	ISCSI                *ISCSIVolumeSource `json:"iscsi,omitempty"`

	Cinder               *CinderVolumeSource `json:"cinder,omitempty"`

	CephFS               *CephFSVolumeSource `json:"cephfs,omitempty"`

	FC                   *FCVolumeSource `json:"fc,omitempty"`
	Flocker              *FlockerVolumeSource `json:"flocker,omitempty"`
	FlexVolume           *FlexVolumeSource `json:"flexVolume,omitempty"`
	AzureFile            *AzureFileVolumeSource `json:"azureFile,omitempty"`
}

type TypeMeta struct {
	Kind       string `json:"kind,omitempty"`

	APIVersion string `json:"apiVersion,omitempty"`
}

func (tm TypeMeta) SetTmProp(apiversion string, kind string) {
	tm.APIVersion = apiversion
	tm.Kind = kind
}

type ListMeta struct {
	SelfLink        string `json:"selfLink,omitempty"`

	ResourceVersion string `json:"resourceVersion,omitempty"`
}
type PersistentVolume struct {
	TypeMeta `json:",inline"`

	ObjectMeta `json:"metadata,omitempty"`

	Spec   PersistentVolumeSpec `json:"spec,omitempty"`

	Status PersistentVolumeStatus `json:"status,omitempty"`
}

type PersistentVolumeSpec struct {
	Capacity                      ResourceList `json:"capacity,omitempty"`

	PersistentVolumeSource `json:",inline"`

	AccessModes                   []PersistentVolumeAccessMode `json:"accessModes,omitempty"`

	ClaimRef                      *ObjectReference `json:"claimRef,omitempty"`

	PersistentVolumeReclaimPolicy PersistentVolumeReclaimPolicy `json:"persistentVolumeReclaimPolicy,omitempty"`
}

type PersistentVolumeReclaimPolicy string

const (
	PersistentVolumeReclaimRecycle PersistentVolumeReclaimPolicy = "Recycle"

	PersistentVolumeReclaimDelete PersistentVolumeReclaimPolicy = "Delete"

	PersistentVolumeReclaimRetain PersistentVolumeReclaimPolicy = "Retain"
)

type PersistentVolumeStatus struct {
	Phase   PersistentVolumePhase `json:"phase,omitempty"`

	Message string `json:"message,omitempty"`

	Reason  string `json:"reason,omitempty"`
}

type PersistentVolumeList struct {
	TypeMeta `json:",inline"`

	ListMeta `json:"metadata,omitempty"`

	Items []PersistentVolume `json:"items"`
}

type PersistentVolumeClaim struct {
	TypeMeta `json:",inline"`

	ObjectMeta `json:"metadata,omitempty"`

	Spec   PersistentVolumeClaimSpec `json:"spec,omitempty"`

	Status PersistentVolumeClaimStatus `json:"status,omitempty"`
}

type PersistentVolumeClaimList struct {
	TypeMeta `json:",inline"`

	ListMeta `json:"metadata,omitempty"`

	Items []PersistentVolumeClaim `json:"items"`
}

type PersistentVolumeClaimSpec struct {
	AccessModes []PersistentVolumeAccessMode `json:"accessModes,omitempty"`

	Resources   ResourceRequirements `json:"resources,omitempty"`

	VolumeName  string `json:"volumeName,omitempty"`
}

type PersistentVolumeClaimStatus struct {
	Phase       PersistentVolumeClaimPhase `json:"phase,omitempty"`

	AccessModes []PersistentVolumeAccessMode `json:"accessModes,omitempty"`

	Capacity    ResourceList `json:"capacity,omitempty"`
}

type PersistentVolumeAccessMode string

const (
	ReadWriteOnce PersistentVolumeAccessMode = "ReadWriteOnce"

	ReadOnlyMany PersistentVolumeAccessMode = "ReadOnlyMany"

	ReadWriteMany PersistentVolumeAccessMode = "ReadWriteMany"
)

type PersistentVolumePhase string

const (
	VolumePending PersistentVolumePhase = "Pending"

	VolumeAvailable PersistentVolumePhase = "Available"

	VolumeBound PersistentVolumePhase = "Bound"

	VolumeReleased PersistentVolumePhase = "Released"

	VolumeFailed PersistentVolumePhase = "Failed"
)

type PersistentVolumeClaimPhase string

const (
	ClaimPending PersistentVolumeClaimPhase = "Pending"
	ClaimBound PersistentVolumeClaimPhase = "Bound"
)

type HostPathVolumeSource struct {
	Path string `json:"path"`
}

type EmptyDirVolumeSource struct {
	Medium StorageMedium `json:"medium,omitempty"`
}

type GlusterfsVolumeSource struct {
	EndpointsName string `json:"endpoints"`

	Path          string `json:"path"`

	ReadOnly      bool `json:"readOnly,omitempty"`
}

type RBDVolumeSource struct {
	CephMonitors []string `json:"monitors"`
	RBDImage     string `json:"image"`
	FSType       string `json:"fsType,omitempty"`
	RBDPool      string `json:"pool"`
	RadosUser    string `json:"user"`
	Keyring      string `json:"keyring"`
	SecretRef    *LocalObjectReference `json:"secretRef"`
	ReadOnly     bool `json:"readOnly,omitempty"`
}

type CinderVolumeSource struct {
	VolumeID string `json:"volumeID"`
	FSType   string `json:"fsType,omitempty"`
	ReadOnly bool `json:"readOnly,omitempty"`
}

type CephFSVolumeSource struct {
	Monitors   []string `json:"monitors"`
	Path       string `json:"path,omitempty"`
	User       string `json:"user,omitempty"`
	SecretFile string `json:"secretFile,omitempty"`
	SecretRef  *LocalObjectReference `json:"secretRef,omitempty"`
	ReadOnly   bool `json:"readOnly,omitempty"`
}

type FlockerVolumeSource struct {
	DatasetName string `json:"datasetName"`
}

type StorageMedium string

const (
	StorageMediumDefault StorageMedium = ""
	StorageMediumMemory StorageMedium = "Memory"
)

type Protocol string

const (
	ProtocolTCP Protocol = "TCP"
	ProtocolUDP Protocol = "UDP"
)

type GCEPersistentDiskVolumeSource struct {
	PDName    string `json:"pdName"`
	FSType    string `json:"fsType,omitempty"`
	Partition int32 `json:"partition,omitempty"`
	ReadOnly  bool `json:"readOnly,omitempty"`
}

type FlexVolumeSource struct {
	Driver    string `json:"driver"`
	FSType    string `json:"fsType,omitempty"`
	SecretRef *LocalObjectReference `json:"secretRef,omitempty"`
	ReadOnly  bool `json:"readOnly,omitempty"`
	Options   map[string]string `json:"options,omitempty"`
}

type AWSElasticBlockStoreVolumeSource struct {
	VolumeID  string `json:"volumeID"`

	FSType    string `json:"fsType,omitempty"`
	Partition int32 `json:"partition,omitempty"`
	ReadOnly  bool `json:"readOnly,omitempty"`
}

type GitRepoVolumeSource struct {
	Repository string `json:"repository"`
	Revision   string `json:"revision,omitempty"`
	Directory  string `json:"directory,omitempty"`
}

type SecretVolumeSource struct {
	SecretName string `json:"secretName,omitempty"`
}

type NFSVolumeSource struct {
	Server   string `json:"server"`

	Path     string `json:"path"`

	ReadOnly bool `json:"readOnly,omitempty"`
}

type ISCSIVolumeSource struct {
	TargetPortal   string `json:"targetPortal"`
	IQN            string `json:"iqn"`
	Lun            int32 `json:"lun"`
	ISCSIInterface string `json:"iscsiInterface,omitempty"`

	FSType         string `json:"fsType,omitempty"`
	ReadOnly       bool `json:"readOnly,omitempty"`
}

type FCVolumeSource struct {
	TargetWWNs []string `json:"targetWWNs"`
	Lun        *int32 `json:"lun"`
	FSType     string `json:"fsType,omitempty"`
	ReadOnly   bool `json:"readOnly,omitempty"`
}

type AzureFileVolumeSource struct {
	SecretName string `json:"secretName"`
	ShareName  string `json:"shareName"`
	ReadOnly   bool `json:"readOnly,omitempty"`
}

type ConfigMapVolumeSource struct {
	LocalObjectReference `json:",inline"`
	Items []KeyToPath `json:"items,omitempty"`
}

type KeyToPath struct {
	Key  string `json:"key"`

	Path string `json:"path"`
}

type ContainerPort struct {
	Name          string `json:"name,omitempty"`
	HostPort      int32 `json:"hostPort,omitempty"`
	ContainerPort int32 `json:"containerPort"`
	Protocol      Protocol `json:"protocol,omitempty"`
	HostIP        string `json:"hostIP,omitempty"`
}

type VolumeMount struct {
	Name      string `json:"name"`
	ReadOnly  bool `json:"readOnly,omitempty"`
	MountPath string `json:"mountPath"`
}

type EnvVar struct {
	Name      string `json:"name"`
	Value     string `json:"value,omitempty"`
	ValueFrom *EnvVarSource `json:"valueFrom,omitempty"`
}

type EnvVarSource struct {
	FieldRef        *ObjectFieldSelector `json:"fieldRef,omitempty"`
	ConfigMapKeyRef *ConfigMapKeySelector `json:"configMapKeyRef,omitempty"`
	SecretKeyRef    *SecretKeySelector `json:"secretKeyRef,omitempty"`
}

type ObjectFieldSelector struct {
	APIVersion string `json:"apiVersion,omitempty"`
	FieldPath  string `json:"fieldPath"`
}

type ConfigMapKeySelector struct {
	LocalObjectReference `json:",inline"`
	Key string `json:"key"`
}

type SecretKeySelector struct {
	LocalObjectReference `json:",inline"`
	Key string `json:"key"`
}

type HTTPHeader struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}
type IntOrString struct {
	Type   int
	IntVal int32
	StrVal string
}

type HTTPGetAction struct {
	Path        string `json:"path,omitempty"`
	Port        int32 `json:"port"`
	Host        string `json:"host,omitempty"`
	Scheme      URIScheme `json:"scheme,omitempty"`
	HTTPHeaders []HTTPHeader `json:"httpHeaders,omitempty"`
}

type URIScheme string

const (
	URISchemeHTTP URIScheme = "HTTP"
	URISchemeHTTPS URIScheme = "HTTPS"
)

type TCPSocketAction struct {
	Port IntOrString `json:"port"`
}

type ExecAction struct {
	Command []string `json:"command,omitempty"`
}

type Probe struct {
	Handler `json:",inline"`
	InitialDelaySeconds int32 `json:"initialDelaySeconds,omitempty"`
	TimeoutSeconds      int32 `json:"timeoutSeconds,omitempty"`
	PeriodSeconds       int32 `json:"periodSeconds,omitempty"`
	SuccessThreshold    int32 `json:"successThreshold,omitempty"`
	FailureThreshold    int32 `json:"failureThreshold,omitempty"`
}

type PullPolicy string

const (
	PullAlways PullPolicy = "Always"
	PullNever PullPolicy = "Never"
	PullIfNotPresent PullPolicy = "IfNotPresent"
)

type Capability string

type Capabilities struct {
	Add  []Capability `json:"add,omitempty"`

	Drop []Capability `json:"drop,omitempty"`
}

type ResourceRequirements struct {
	Limits   ResourceList `json:"limits,omitempty"`
	Requests ResourceList `json:"requests,omitempty"`
}

func (resource ResourceRequirements) SetResource(cpu_min string, cpu_max string, mem_max string, mem_min string) {
	resource.Limits = make(map[ResourceName]string)
	resource.Limits["cpu"] = cpu_max
	resource.Limits["memory"] = mem_max
	resource.Requests = make(map[ResourceName]string)
	resource.Requests["cpu"] = cpu_min
	resource.Requests["memory"] = mem_min
}

const (
	TerminationMessagePathDefault string = "/dev/termination-log"
)

type Container struct {
	Name                   string `json:"name"`
	Image                  string `json:"image,omitempty"`
	Command                []string `json:"command,omitempty"`
	Args                   []string `json:"args,omitempty"`
	WorkingDir             string `json:"workingDir,omitempty"`
	Ports                  []ContainerPort `json:"ports,omitempty" patchStrategy:"merge" patchMergeKey:"containerPort"`
	Env                    []EnvVar `json:"env,omitempty" patchStrategy:"merge" patchMergeKey:"name"`
	Resources              ResourceRequirements `json:"resources,omitempty"`
	VolumeMounts           []VolumeMount `json:"volumeMounts,omitempty" patchStrategy:"merge" patchMergeKey:"name"`
	LivenessProbe          *Probe `json:"livenessProbe,omitempty"`
	ReadinessProbe         *Probe `json:"readinessProbe,omitempty"`
	Lifecycle              *Lifecycle `json:"lifecycle,omitempty"`
	TerminationMessagePath string `json:"terminationMessagePath,omitempty"`
	ImagePullPolicy        PullPolicy `json:"imagePullPolicy,omitempty"`
	SecurityContext        *SecurityContext `json:"securityContext,omitempty"`
	Stdin                  bool `json:"stdin,omitempty"`
	StdinOnce              bool `json:"stdinOnce,omitempty"`
	TTY                    bool `json:"tty,omitempty"`
}

type Handler struct {
	Exec      *ExecAction `json:"exec,omitempty"`
	HTTPGet   *HTTPGetAction `json:"httpGet,omitempty"`
	TCPSocket *TCPSocketAction `json:"tcpSocket,omitempty"`
}

type Lifecycle struct {
	PostStart *Handler `json:"postStart,omitempty"`
	PreStop   *Handler `json:"preStop,omitempty"`
}

type ConditionStatus string

const (
	ConditionTrue ConditionStatus = "True"
	ConditionFalse ConditionStatus = "False"
	ConditionUnknown ConditionStatus = "Unknown"
)

type ContainerStateWaiting struct {
	Reason  string `json:"reason,omitempty"`
	Message string `json:"message,omitempty"`
}

type ContainerStateRunning struct {
	StartedAt string `json:"startedAt,omitempty"`
}

type ContainerStateTerminated struct {
	ExitCode    int32 `json:"exitCode"`
	Signal      int32 `json:"signal,omitempty"`
	Reason      string `json:"reason,omitempty"`
	Message     string `json:"message,omitempty"`
	StartedAt   string `json:"startedAt,omitempty"`
	FinishedAt  string `json:"finishedAt,omitempty"`
	ContainerID string `json:"containerID,omitempty"`
}

type ContainerState struct {
	Waiting    *ContainerStateWaiting `json:"waiting,omitempty"`
	Running    *ContainerStateRunning `json:"running,omitempty"`
	Terminated *ContainerStateTerminated `json:"terminated,omitempty"`
}

type ContainerStatus struct {
	Name                 string `json:"name"`
	State                ContainerState `json:"state,omitempty"`
	LastTerminationState ContainerState `json:"lastState,omitempty"`
	Ready                bool `json:"ready"`
	RestartCount         int32 `json:"restartCount"`
	Image                string `json:"image"`
	ImageID              string `json:"imageID"`
	ContainerID          string `json:"containerID,omitempty"`
}

type PodPhase string

// These are the valid statuses of pods.
const (
	// PodPending means the pod has been accepted by the system, but one or more of the containers
	// has not been started. This includes time before being bound to a node, as well as time spent
	// pulling images onto the host.
	PodPending PodPhase = "Pending"
	// PodRunning means the pod has been bound to a node and all of the containers have been started.
	// At least one container is still running or is in the process of being restarted.
	PodRunning PodPhase = "Running"
	// PodSucceeded means that all containers in the pod have voluntarily terminated
	// with a container exit code of 0, and the system is not going to restart any of these containers.
	PodSucceeded PodPhase = "Succeeded"
	// PodFailed means that all containers in the pod have terminated, and at least one container has
	// terminated in a failure (exited with a non-zero exit code or was stopped by the system).
	PodFailed PodPhase = "Failed"
	// PodUnknown means that for some reason the state of the pod could not be obtained, typically due
	// to an error in communicating with the host of the pod.
	PodUnknown PodPhase = "Unknown"
)

type PodConditionType string

// These are valid conditions of pod.
const (
	// PodScheduled represents status of the scheduling process for this pod.
	PodScheduled PodConditionType = "PodScheduled"
	// PodReady means the pod is able to service requests and should be added to the
	// load balancing pools of all matching services.
	PodReady PodConditionType = "Ready"
	// PodInitialized means that all init containers in the pod have started successfully.
	PodInitialized PodConditionType = "Initialized"
)

type PodCondition struct {
	Type               PodConditionType `json:"type"`
	Status             ConditionStatus  `json:"status"`
	LastProbeTime      Time `json:"lastProbeTime,omitempty"`
	LastTransitionTime Time `json:"lastTransitionTime,omitempty"`
	Reason             string           `json:"reason,omitempty"`
	Message            string           `json:"message,omitempty"`
}

// RestartPolicy describes how the container should be restarted.
// Only one of the following restart policies may be specified.
// If none of the following policies is specified, the default one
// is RestartPolicyAlways.
type RestartPolicy string

const (
	RestartPolicyAlways RestartPolicy = "Always"
	RestartPolicyOnFailure RestartPolicy = "OnFailure"
	RestartPolicyNever RestartPolicy = "Never"
)

// PodList is a list of Pods.
type PodList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []Pod `json:"items"`
}

func (podlist PodList)GetItems() []*interf.Podinface {
	var v []*interf.Podinface
	for _, pod := range podlist.Items {
		var v1 *interf.Podinface
		*v1 = pod
		v = append(v, v1)
	}
	return v
}

type DNSPolicy string

const (
	DNSClusterFirst DNSPolicy = "ClusterFirst"

	DNSDefault DNSPolicy = "Default"

	DefaultTerminationGracePeriodSeconds = 30
)

type NodeSelector struct {
	NodeSelectorTerms []NodeSelectorTerm `json:"nodeSelectorTerms"`
}

type NodeSelectorTerm struct {
	MatchExpressions []NodeSelectorRequirement `json:"matchExpressions"`
}

type NodeSelectorRequirement struct {
	Key      string `json:"key" patchStrategy:"merge" patchMergeKey:"key"`
	Operator NodeSelectorOperator `json:"operator"`
	Values   []string `json:"values,omitempty"`
}

type NodeSelectorOperator string

const (
	NodeSelectorOpIn NodeSelectorOperator = "In"
	NodeSelectorOpNotIn NodeSelectorOperator = "NotIn"
	NodeSelectorOpExists NodeSelectorOperator = "Exists"
	NodeSelectorOpDoesNotExist NodeSelectorOperator = "DoesNotExist"
	NodeSelectorOpGt NodeSelectorOperator = "Gt"
	NodeSelectorOpLt NodeSelectorOperator = "Lt"
)

type Affinity struct {
	NodeAffinity *NodeAffinity `json:"nodeAffinity,omitempty"`
}

type NodeAffinity struct {
	RequiredDuringSchedulingIgnoredDuringExecution  *NodeSelector `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
	PreferredDuringSchedulingIgnoredDuringExecution []PreferredSchedulingTerm `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type PreferredSchedulingTerm struct {
	Weight     int `json:"weight"`
	Preference NodeSelectorTerm `json:"preference"`
}

type PodSpec struct {
	Volumes                       []Volume `json:"volumes"`
	// List of initialization containers belonging to the pod.
	InitContainers                []Container `json:"-"`
	// List of containers belonging to the pod.
	Containers                    []Container   `json:"containers"`
	RestartPolicy                 RestartPolicy `json:"restartPolicy,omitempty"`
	// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
	// Value must be non-negative integer. The value zero indicates delete immediately.
	// If this value is nil, the default grace period will be used instead.
	// The grace period is the duration in seconds after the processes running in the pod are sent
	// a termination signal and the time when the processes are forcibly halted with a kill signal.
	// Set this value longer than the expected cleanup time for your process.
	TerminationGracePeriodSeconds *int64 `json:"terminationGracePeriodSeconds,omitempty"`
	// Optional duration in seconds relative to the StartTime that the pod may be active on a node
	// before the system actively tries to terminate the pod; value must be positive integer
	ActiveDeadlineSeconds         *int64 `json:"activeDeadlineSeconds,omitempty"`
	// Required: Set DNS policy.
	DNSPolicy                     DNSPolicy `json:"dnsPolicy,omitempty"`
	// NodeSelector is a selector which must be true for the pod to fit on a node
	NodeSelector                  map[string]string `json:"nodeSelector,omitempty"`

	// ServiceAccountName is the name of the ServiceAccount to use to run this pod
	// The pod will be allowed to use secrets referenced by the ServiceAccount
	ServiceAccountName            string `json:"serviceAccountName"`

	// NodeName is a request to schedule this pod onto a specific node.  If it is non-empty,
	// the scheduler simply schedules this pod onto that node, assuming that it fits resource
	// requirements.
	NodeName                      string `json:"nodeName,omitempty"`
	// SecurityContext holds pod-level security attributes and common container settings.
	// Optional: Defaults to empty.  See type description for default values of each field.
	SecurityContext               *PodSecurityContext `json:"securityContext,omitempty"`
	// ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
	// If specified, these secrets will be passed to individual puller implementations for them to use.  For example,
	// in the case of docker, only DockerConfig type secrets are honored.
	ImagePullSecrets              []LocalObjectReference `json:"imagePullSecrets,omitempty"`
	// Specifies the hostname of the Pod.
	// If not specified, the pod's hostname will be set to a system-defined value.
	Hostname                      string `json:"hostname,omitempty"`
	// If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
	// If not specified, the pod will not have a domainname at all.
	Subdomain                     string `json:"subdomain,omitempty"`
}

// Sysctl defines a kernel parameter to be set
type Sysctl struct {
	// Name of a property to set
	Name  string `json:"name"`
	// Value of a property to set
	Value string `json:"value"`
}

func PrintResourceList(resource ResourceList) string {
	var str string = ""
	for key, value := range resource {
		str += "资源名:" + string(key) + ",剩余量: " + value + "\n"
		//fmt.Println("资源名:", key, ",剩余量: ", value)
	}
	return str
}
func PrintNodeResourceStatus(node Node) string {
	//fmt.Println("nodeName: ", node.Name)
	//fmt.Println("总资源: ")
	//PrintResourceList(node.Status.Capacity)
	//fmt.Println("剩余可用资源: ")
	//PrintResourceList(node.Status.Allocatable)
	return "nodeName: " + node.Name + "\n" + "总资源: \n" + PrintResourceList(node.Status.Capacity) + "\n" + "剩余可用资源: \n" + PrintResourceList(node.Status.Allocatable)
}

func PrintJob(job Job) {
	fmt.Println("Job Message:")
	fmt.Println("Job Object: ", job.ObjectMeta)
	fmt.Println("Job TypeMeta:", job.TypeMeta)
	fmt.Println("Job Spec:", job.Spec)
	fmt.Println("Job Status", job.Status)
}

func PrintReplicationController(replicationcontroller ReplicationController) {
	fmt.Print("Replicationcontroller Message:\n")
	fmt.Print("ReplicationcontrollerName: " + replicationcontroller.Name + "\n")
	fmt.Print("Namespace: " + replicationcontroller.Namespace + "\n")
	fmt.Print("Kind: " + replicationcontroller.TypeMeta.APIVersion + "\n")
	fmt.Print("APIVersion: " + replicationcontroller.TypeMeta.Kind + "\n")
	fmt.Print("CreationTimestamp: " + replicationcontroller.CreationTimestamp + "\n")
	fmt.Print("Labels: ")
	fmt.Print(replicationcontroller.Labels)
	fmt.Print("\n")
	fmt.Print("Spec: ")
	fmt.Print(replicationcontroller.Spec)
	fmt.Print("\n")
	fmt.Print("Status: ")
	fmt.Print(replicationcontroller.Status)
	fmt.Print("\n")
}

func PrintService(service Service) {
	fmt.Print("Service Message:\n")
	fmt.Print("ServiceName: " + service.Name + "\n")
	fmt.Print("Namespace: " + service.Namespace + "\n")
	fmt.Print("Kind: " + service.TypeMeta.APIVersion + "\n")
	fmt.Print("APIVersion: " + service.TypeMeta.Kind + "\n")
	fmt.Print("CreationTimestamp: " + service.CreationTimestamp + "\n")
	fmt.Print("Labels: ")
	fmt.Print(service.Labels)
	fmt.Print("\n")
	fmt.Print("Spec: ")
	fmt.Print(service.Spec)
	fmt.Print("\n")
	fmt.Print("tatus: ")
	fmt.Print(service.Status)
	fmt.Print("\n")
}

func PrintNode(node Node) {
	fmt.Print("Node Message:\n")
	fmt.Print("NodeName: " + node.Name + "\n")
	fmt.Print("Namespace: " + node.Namespace + "\n")
	fmt.Print("Kind: " + node.TypeMeta.APIVersion + "\n")
	fmt.Print("APIVersion: " + node.TypeMeta.Kind + "\n")
	fmt.Print("CreationTimestamp: " + node.CreationTimestamp + "\n")
	fmt.Print("Labels: ")
	fmt.Print(node.Labels)
	fmt.Print("\n")
	fmt.Print("Spec: ")
	fmt.Print(node.Spec)
	fmt.Print("\n")
	fmt.Print("Status: ")
	fmt.Print(node.Status)
	fmt.Print("\n")
}
func PrintNamespace(namespace Namespace) {
	fmt.Print("Namespace Message:\n")
	fmt.Print("Name: " + namespace.Name + "\n")
	fmt.Print("CreationTimestamp: " + namespace.CreationTimestamp + "\n")
	fmt.Print("Labels: ")
	fmt.Print(namespace.Labels)
	fmt.Print("\n")
	fmt.Print("Spec: ")
	fmt.Print(namespace.Spec)
	fmt.Print("\n")
	fmt.Print("Status: ")
	fmt.Print(namespace.Status)
	fmt.Print("\n")
	fmt.Print("ObjectMeta: ")
	fmt.Print(namespace.ObjectMeta)
	fmt.Print("\n")
}
func PrintPod(pod Pod) {
	fmt.Print("Pod Message:\n")
	fmt.Print("Name: " + pod.Name + "\n")
	fmt.Print("CreationTimestamp: " + pod.CreationTimestamp + "\n")
	fmt.Print("spec: ")
	fmt.Print(pod.Spec)
	fmt.Print("\n")
	fmt.Print("ObjectMeta: ")
	fmt.Print(pod.ObjectMeta)
	fmt.Print("\n")
	fmt.Print("Status: ")
	fmt.Print(pod.Status)
	fmt.Print("\n")
	fmt.Print("Labels: ")
	fmt.Print(pod.Labels)
	fmt.Print("\n")
}

// PodSecurityContext holds pod-level security attributes and common container settings.
// Some fields are also present in container.securityContext.  Field values of
// container.securityContext take precedence over field values of PodSecurityContext.
type PodSecurityContext struct {
	// Use the host's network namespace.  If this option is set, the ports that will be
	// used must be specified.
	// Optional: Default to false
	// +k8s:conversion-gen=false
	HostNetwork        bool `json:"hostNetwork,omitempty"`
	// Use the host's pid namespace.
	// Optional: Default to false.
	// +k8s:conversion-gen=false
	HostPID            bool `json:"hostPID,omitempty"`
	// Use the host's ipc namespace.
	// Optional: Default to false.
	// +k8s:conversion-gen=false
	HostIPC            bool `json:"hostIPC,omitempty"`
	// The SELinux context to be applied to all containers.
	// If unspecified, the container runtime will allocate a random SELinux context for each
	// container.  May also be set in SecurityContext.  If set in
	// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
	// takes precedence for that container.
	SELinuxOptions     *SELinuxOptions `json:"seLinuxOptions,omitempty"`
	// The UID to run the entrypoint of the container process.
	// Defaults to user specified in image metadata if unspecified.
	// May also be set in SecurityContext.  If set in both SecurityContext and
	// PodSecurityContext, the value specified in SecurityContext takes precedence
	// for that container.
	RunAsUser          *int64 `json:"runAsUser,omitempty"`
	// Indicates that the container must run as a non-root user.
	// If true, the Kubelet will validate the image at runtime to ensure that it
	// does not run as UID 0 (root) and fail to start the container if it does.
	// If unset or false, no such validation will be performed.
	// May also be set in SecurityContext.  If set in both SecurityContext and
	// PodSecurityContext, the value specified in SecurityContext takes precedence.
	RunAsNonRoot       *bool `json:"runAsNonRoot,omitempty"`
	// A list of groups applied to the first process run in each container, in addition
	// to the container's primary GID.  If unspecified, no groups will be added to
	// any container.
	SupplementalGroups []int64 `json:"supplementalGroups,omitempty"`
	// A special supplemental group that applies to all containers in a pod.
	// Some volume types allow the Kubelet to change the ownership of that volume
	// to be owned by the pod:
	//
	// 1. The owning GID will be the FSGroup
	// 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
	// 3. The permission bits are OR'd with rw-rw----
	//
	// If unset, the Kubelet will not modify the ownership and permissions of any volume.
	FSGroup            *int64 `json:"fsGroup,omitempty"`
}

// PodStatus represents information about the status of a pod. Status may trail the actual
// state of a system.
type PodStatus struct {
	Phase                 PodPhase       `json:"phase,omitempty"`
	Conditions            []PodCondition `json:"conditions,omitempty"`
	// A human readable message indicating details about why the pod is in this state.
	Message               string `json:"message,omitempty"`
	// A brief CamelCase message indicating details about why the pod is in this state. e.g. 'OutOfDisk'
	Reason                string `json:"reason,omitempty"`

	HostIP                string `json:"hostIP,omitempty"`
	PodIP                 string `json:"podIP,omitempty"`

	// Date and time at which the object was acknowledged by the Kubelet.
	// This is before the Kubelet pulled the container image(s) for the pod.
	StartTime             *Time `json:"startTime,omitempty"`

	// The list has one entry per init container in the manifest. The most recent successful
	// init container will have ready = true, the most recently started container will have
	// startTime set.
	// More info: http://releases.k8s.io/HEAD/docs/user-guide/pod-states.md#container-statuses
	InitContainerStatuses []ContainerStatus `json:"-"`
	// The list has one entry per container in the manifest. Each entry is
	// currently the output of `docker inspect`. This output format is *not*
	// final and should not be relied upon.
	// TODO: Make real decisions about what our info should look like. Re-enable fuzz test
	// when we have done this.
	ContainerStatuses     []ContainerStatus `json:"containerStatuses,omitempty"`
}

// PodStatusResult is a wrapper for PodStatus returned by kubelet that can be encode/decoded
type PodStatusResult struct {
	TypeMeta `json:",inline"`
	ObjectMeta           `json:"metadata,omitempty"`
	// Status represents the current information about a pod. This data may not be up
	// to date.
	Status PodStatus `json:"status,omitempty"`
}

// +genclient=true

// Pod is a collection of containers, used as either input (create, update) or as output (list, get).
type Pod struct {
	TypeMeta `json:",inline"`
	ObjectMeta           `json:"metadata,omitempty"`

	// Spec defines the behavior of a pod.
	Spec   PodSpec `json:"spec,omitempty"`

	// Status represents the current information about a pod. This data may not be up
	// to date.
	Status PodStatus `json:"status,omitempty"`
}

func (p Pod) SetPod(apiversion string, kind string, name string, namespace string, image string, cpu string, mem string, command string) []byte {
	var typeMeta TypeMeta
	typeMeta.APIVersion = apiversion
	typeMeta.Kind = kind
	p.TypeMeta = typeMeta

	var objectMedata ObjectMeta
	objectMedata.Labels = make(map[string]string)
	objectMedata.Labels["name"] = name
	objectMedata.Namespace = namespace
	objectMedata.Name = name
	p.ObjectMeta = objectMedata

	var resource ResourceRequirements
	resource.Limits = make(map[ResourceName]string)
	resource.Limits["cpu"] = cpu
	resource.Limits["memory"] = mem
	resource.Requests = make(map[ResourceName]string)
	resource.Requests["cpu"] = cpu
	resource.Requests["memory"] = mem
	var container Container
	container.Name = name
	container.Image = image
	container.Resources = resource
	container.Command = strings.Split(command, " ")
	var containers [1]Container
	containers[0] = container
	//
	//pod.TypeMeta = typeMedata
	//pod.ObjectMeta = objectMedata
	//将container拷到pod.spec.containers
	slice := []Container{container}
	p.Spec.Containers = slice
	p.Spec.RestartPolicy = "Always"

	b, _ := json.Marshal(&p)
	return b

}

func (p Pod) GetNamespace() string {
	return p.Namespace
}
func (p Pod) GetCpu() string {
	return p.Spec.Containers[0].Resources.Requests["cpu"]
}
func (p Pod) GetMem() string {
	return p.Spec.Containers[0].Resources.Requests["memory"]
}
func (p Pod) GetLabel(name string) string {
	return p.Labels[name]
}

func (p Pod) SetContainer(name string, image string, cpu string, mem string, command string, restart string) {
	var resource ResourceRequirements
	resource.Limits = make(map[ResourceName]string)
	resource.Limits["cpu"] = cpu
	resource.Limits["memory"] = mem
	resource.Requests = make(map[ResourceName]string)
	resource.Requests["cpu"] = cpu
	resource.Requests["memory"] = mem
	var container Container
	container.Name = name
	container.Image = image
	container.Resources = resource
	container.Command = strings.Split(command, " ")
	var containers [1]Container
	containers[0] = container
	//
	//pod.TypeMeta = typeMedata
	//pod.ObjectMeta = objectMedata
	//将container拷到pod.spec.containers
	slice := []Container{container}
	p.Spec.Containers = slice
	p.Spec.RestartPolicy = "Always"
}

func (p Pod)SetObjectMeta(labelname string, namespace string, name string) {
	var objectMedata ObjectMeta
	objectMedata.Labels = make(map[string]string)
	objectMedata.Labels["name"] = labelname
	objectMedata.Namespace = namespace
	objectMedata.Name = name
	p.ObjectMeta = objectMedata
}

func (p Pod)SetTypeMeta(apiVersion string, kind string) {
	var typeMeta TypeMeta
	typeMeta.APIVersion = apiVersion
	typeMeta.Kind = kind
	p.TypeMeta = typeMeta
}

func (pod Pod) GetNodeName() string {
	return pod.Spec.NodeName
}

func (pod Pod) GetName() string {
	return pod.Name
}
func (pod Pod)GetStautsPhase() string {
	return string(pod.Status.Phase)
}
func (pod Pod) GetContainerStatusesLen() int {
	return len(pod.Status.ContainerStatuses)
}
func (pod Pod) GetReady() bool {
	return pod.Status.ContainerStatuses[0].Ready
}

// PodTemplateSpec describes the data a pod should have when created from a template
type PodTemplateSpec struct {
	// Metadata of the pods created from this template.
	ObjectMeta `json:"metadata,omitempty"`

	// Spec defines the behavior of a pod.
	Spec PodSpec `json:"spec,omitempty"`
}

// +genclient=true

// PodTemplate describes a template for creating copies of a predefined pod.
type PodTemplate struct {
	TypeMeta `json:",inline"`
	ObjectMeta           `json:"metadata,omitempty"`

	// Template defines the pods that will be created from this pod template
	Template PodTemplateSpec `json:"template,omitempty"`
}

// PodTemplateList is a list of PodTemplates.
type PodTemplateList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []PodTemplate `json:"items"`
}
type ReplicationControllerSpec struct {
	Replicas *int32 `json:"replicas,omitempty"`
	Selector map[string]string `json:"selector,omitempty"`
	Template *PodTemplateSpec `json:"template,omitempty"`
}

type ReplicationControllerStatus struct {
	Replicas           int32 `json:"replicas"`

	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
}

type ReplicationController struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Spec   ReplicationControllerSpec `json:"spec,omitempty"`

	Status ReplicationControllerStatus `json:"status,omitempty"`
}

type ReplicationControllerList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []ReplicationController `json:"items"`
}

type ServiceAffinity string

const (
	ServiceAffinityClientIP ServiceAffinity = "ClientIP"

	ServiceAffinityNone ServiceAffinity = "None"
)

type ServiceType string

const (
	ServiceTypeClusterIP ServiceType = "ClusterIP"

	ServiceTypeNodePort ServiceType = "NodePort"

	ServiceTypeLoadBalancer ServiceType = "LoadBalancer"
)

type ServiceStatus struct {
	LoadBalancer LoadBalancerStatus `json:"loadBalancer,omitempty"`
}

type LoadBalancerStatus struct {
	Ingress []LoadBalancerIngress `json:"ingress,omitempty"`
}

type LoadBalancerIngress struct {
	IP       string `json:"ip,omitempty"`

	Hostname string `json:"hostname,omitempty"`
}

type ServiceSpec struct {
	Ports               []ServicePort `json:"ports"`

	Selector            map[string]string `json:"selector,omitempty"`

	ClusterIP           string `json:"clusterIP,omitempty"`

	Type                ServiceType `json:"type,omitempty"`

	ExternalIPs         []string `json:"externalIPs,omitempty"`

	DeprecatedPublicIPs []string `json:"deprecatedPublicIPs,omitempty"`

	SessionAffinity     ServiceAffinity `json:"sessionAffinity,omitempty"`

	LoadBalancerIP      string `json:"loadBalancerIP,omitempty"`
}

type ServicePort struct {
	Name       string `json:"name,omitempty"`

	Protocol   Protocol `json:"protocol,omitempty"`

	Port       int32 `json:"port"`

	TargetPort int `json:"targetPort,omitempty"` //IntOrString

	NodePort   int32 `json:"nodePort,omitempty"`
}

type Service struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Spec   ServiceSpec `json:"spec,omitempty"`

	Status ServiceStatus `json:"status,omitempty"`
}

const (
	ClusterIPNone = "None"
)

type ServiceList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []Service `json:"items"`
}

type ServiceAccount struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Secrets          []ObjectReference `json:"secrets,omitempty" patchStrategy:"merge" patchMergeKey:"name"`

	ImagePullSecrets []LocalObjectReference `json:"imagePullSecrets,omitempty"`
}

type ServiceAccountList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []ServiceAccount `json:"items"`
}

type Endpoints struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Subsets []EndpointSubset `json:"subsets"`
}

type EndpointSubset struct {
	Addresses         []EndpointAddress `json:"addresses,omitempty"`
	NotReadyAddresses []EndpointAddress `json:"notReadyAddresses,omitempty"`
	Ports             []EndpointPort `json:"ports,omitempty"`
}

type EndpointAddress struct {
	IP        string `json:"ip"`

	TargetRef *ObjectReference `json:"targetRef,omitempty"`
}

type EndpointPort struct {
	Name     string `json:"name,omitempty"`

	Port     int32 `json:"port"`

	Protocol Protocol `json:"protocol,omitempty"`
}

type EndpointsList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []Endpoints `json:"items"`
}

type NodeSpec struct {
	PodCIDR       string `json:"podCIDR,omitempty"`
	ExternalID    string `json:"externalID,omitempty"`
	ProviderID    string `json:"providerID,omitempty"`
	Unschedulable bool `json:"unschedulable,omitempty"`
}

type DaemonEndpoint struct {
	Port int32 `json:port`
}

type NodeDaemonEndpoints struct {
	KubeletEndpoint DaemonEndpoint `json:"kubeletEndpoint,omitempty"`
}

type NodeSystemInfo struct {
	MachineID               string `json:"machineID"`
	SystemUUID              string `json:"systemUUID"`
	BootID                  string `json:"bootID"`
	KernelVersion           string `json:"kernelVersion"`
	OSImage                 string `json:"osImage"`
	ContainerRuntimeVersion string `json:"containerRuntimeVersion"`
	KubeletVersion          string `json:"kubeletVersion"`
	KubeProxyVersion        string `json:"kubeProxyVersion"`
}

type NodeStatus struct {
	Capacity        ResourceList `json:"capacity,omitempty"`
	Allocatable     ResourceList `json:"allocatable,omitempty"`
	Phase           NodePhase `json:"phase,omitempty"`
	Conditions      []NodeCondition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type"`
	Addresses       []NodeAddress `json:"addresses,omitempty" patchStrategy:"merge" patchMergeKey:"type"`
	DaemonEndpoints NodeDaemonEndpoints `json:"daemonEndpoints,omitempty"`
	NodeInfo        NodeSystemInfo `json:"nodeInfo,omitempty"`
	Images          []ContainerImage `json:"images",omitempty`
}

type ContainerImage struct {
	Names     []string `json:"names"`
	SizeBytes int64 `json:"sizeBytes,omitempty"`
}

type NodePhase string

const (
	NodePending NodePhase = "Pending"
	NodeRunning NodePhase = "Running"
	NodeTerminated NodePhase = "Terminated"
)

type NodeConditionType string

const (
	NodeReady NodeConditionType = "Ready"
	NodeOutOfDisk NodeConditionType = "OutOfDisk"
)

type NodeCondition struct {
	Type               NodeConditionType `json:"type"`
	Status             ConditionStatus `json:"status"`
	LastHeartbeatTime  string `json:"lastHeartbeatTime,omitempty"`
	LastTransitionTime string `json:"lastTransitionTime,omitempty"`
	Reason             string `json:"reason,omitempty"`
	Message            string `json:"message,omitempty"`
}

type NodeAddressType string

const (
	NodeHostName NodeAddressType = "Hostname"
	NodeExternalIP NodeAddressType = "ExternalIP"
	NodeInternalIP NodeAddressType = "InternalIP"
)

type NodeAddress struct {
	Type    NodeAddressType `json:"type"`
	Address string `json:"address"`
}

type ResourceName string

const (
	ResourceCPU ResourceName = "cpu"
	ResourceMemory ResourceName = "memory"
	ResourceStorage ResourceName = "storage"
)

type Quantity struct {
	Amount *inf.Dec

	string
}

type ResourceList map[ResourceName]string

type Node struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Spec   NodeSpec `json:"spec,omitempty"`

	Status NodeStatus `json:"status,omitempty"`
}

type NodeList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []Node `json:"items"`
}

type FinalizerName string

const (
	FinalizerKubernetes FinalizerName = "kubernetes"
)

type NamespaceSpec struct {
	Finalizers []FinalizerName `json:"finalizers,omitempty"`
}

type NamespaceStatus struct {
	Phase NamespacePhase `json:"phase,omitempty"`
}

type NamespacePhase string

const (
	NamespaceActive NamespacePhase = "Active"
	NamespaceTerminating NamespacePhase = "Terminating"
)

type Namespace struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Spec   NamespaceSpec `json:"spec,omitempty"`

	Status NamespaceStatus `json:"status,omitempty"`
}

type NamespaceList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []Namespace `json:"items"`
}

type Binding struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Target ObjectReference `json:"target"`
}

type DeleteOptions struct {
	TypeMeta `json:",inline"`
	GracePeriodSeconds *int64 `json:"gracePeriodSeconds"`
}

type ExportOptions struct {
	TypeMeta `json:",inline"`

	Export bool `json:"export"`
	Exact  bool `json:"exact"`
}

type ListOptions struct {
	TypeMeta `json:",inline"`

	LabelSelector   string `json:"labelSelector,omitempty"`
	FieldSelector   string `json:"fieldSelector,omitempty"`
	Watch           bool `json:"watch,omitempty"`
	ResourceVersion string `json:"resourceVersion,omitempty"`
	TimeoutSeconds  *int64 `json:"timeoutSeconds,omitempty"`
}

type PodLogOptions struct {
	TypeMeta `json:",inline"`

	Container    string `json:"container,omitempty"`
	Follow       bool `json:"follow,omitempty"`
	Previous     bool `json:"previous,omitempty"`
	SinceSeconds *int64 `json:"sinceSeconds,omitempty"`
	SinceTime    *Time `json:"sinceTime,omitempty"`
	Timestamps   bool `json:"timestamps,omitempty"`
	TailLines    *int64 `json:"tailLines,omitempty"`
	LimitBytes   *int64 `json:"limitBytes,omitempty"`
}

type PodAttachOptions struct {
	TypeMeta `json:",inline"`

	// Stdin if true indicates that stdin is to be redirected for the attach call
	Stdin     bool `json:"stdin,omitempty"`

	// Stdout if true indicates that stdout is to be redirected for the attach call
	Stdout    bool `json:"stdout,omitempty"`

	// Stderr if true indicates that stderr is to be redirected for the attach call
	Stderr    bool `json:"stderr,omitempty"`

	// TTY if true indicates that a tty will be allocated for the attach call
	TTY       bool `json:"tty,omitempty"`

	// Container to attach to.
	Container string `json:"container,omitempty"`
}

// PodExecOptions is the query options to a Pod's remote exec call
type PodExecOptions struct {
	TypeMeta

	// Stdin if true indicates that stdin is to be redirected for the exec call
	Stdin     bool

	// Stdout if true indicates that stdout is to be redirected for the exec call
	Stdout    bool

	// Stderr if true indicates that stderr is to be redirected for the exec call
	Stderr    bool

	// TTY if true indicates that a tty will be allocated for the exec call
	TTY       bool

	// Container in which to execute the command.
	Container string

	// Command is the remote command to execute; argv array; not executed within a shell.
	Command   []string
}

// PodProxyOptions is the query options to a Pod's proxy call
type PodProxyOptions struct {
	TypeMeta

	// Path is the URL path to use for the current proxy request
	Path string
}

type NodeProxyOptions struct {
	TypeMeta `json:",inline"`

	Path string `json:"path,omitempty"`
}

type ServiceProxyOptions struct {
	TypeMeta `json:",inline"`

	Path string `json:"path,omitempty"`
}

type ObjectReference struct {
	Kind            string `json:"kind,omitempty"`
	Namespace       string `json:"namespace,omitempty"`
	Name            string `json:"name,omitempty"`
	UID             string `json:"uid,omitempty"`
	APIVersion      string `json:"apiVersion,omitempty"`
	ResourceVersion string `json:"resourceVersion,omitempty"`

	FieldPath       string `json:"fieldPath,omitempty"`
}

type LocalObjectReference struct {
	Name string `json:"name,omitempty"`
}

type SerializedReference struct {
	TypeMeta `json:",inline"`
	Reference ObjectReference `json:"reference,omitempty"`
}

type EventSource struct {
	Component string `json:"component,omitempty"`
	Host      string `json:"host,omitempty"`
}

const (
	EventTypeNormal string = "Normal"
	EventTypeWarning string = "Warning"
)

type Event struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata"`

	InvolvedObject ObjectReference `json:"involvedObject"`

	Reason         string `json:"reason,omitempty"`

	Message        string `json:"message,omitempty"`

	Source         EventSource `json:"source,omitempty"`

	FirstTimestamp Time `json:"firstTimestamp,omitempty"`

	LastTimestamp  Time `json:"lastTimestamp,omitempty"`

	Count          int32 `json:"count,omitempty"`

	Type           string `json:"type,omitempty"`
}

type EventList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []Event `json:"items"`
}

type GroupVersionKind struct {
	Group   string
	Version string
	Kind    string
}
type ObjectKind interface {
	SetGroupVersionKind(kind *GroupVersionKind)
	GroupVersionKind() *GroupVersionKind
}
type Object interface {
	GetObjectKind() ObjectKind
}
type RawExtension struct {
	RawJSON []byte
	Object  Object `json:"-"`
}

type List struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []RawExtension `json:"items"`
}

type LimitType string

const (
	LimitTypePod LimitType = "Pod"
	LimitTypeContainer LimitType = "Container"
)

type LimitRangeItem struct {
	Type                 LimitType `json:"type,omitempty"`
	Max                  ResourceList `json:"max,omitempty"`
	Min                  ResourceList `json:"min,omitempty"`
	Default              ResourceList `json:"default,omitempty"`
	DefaultRequest       ResourceList `json:"defaultRequest,omitempty"`
	MaxLimitRequestRatio ResourceList `json:"maxLimitRequestRatio,omitempty"`
}

type LimitRangeSpec struct {
	Limits []LimitRangeItem `json:"limits"`
}

type LimitRange struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Spec LimitRangeSpec `json:"spec,omitempty"`
}

type LimitRangeList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []LimitRange `json:"items"`
}

const (
	ResourcePods ResourceName = "pods"
	ResourceServices ResourceName = "services"
	ResourceReplicationControllers ResourceName = "replicationcontrollers"
	ResourceQuotas ResourceName = "resourcequotas"
	ResourceSecrets ResourceName = "secrets"
	ResourceConfigMaps ResourceName = "configmaps"
	ResourcePersistentVolumeClaims ResourceName = "persistentvolumeclaims"
	ResourceCPURequest ResourceName = "cpu.request"
	ResourceCPULimit ResourceName = "cpu.limit"
	ResourceMemoryRequest ResourceName = "memory.request"
	ResourceMemoryLimit ResourceName = "memory.limit"
)

type ResourceQuotaScope string

const (
	ResourceQuotaScopeTerminating ResourceQuotaScope = "Terminating"
	ResourceQuotaScopeNotTerminating ResourceQuotaScope = "NotTerminating"
	ResourceQuotaScopeBestEffort ResourceQuotaScope = "BestEffort"
	ResourceQuotaScopeNotBestEffort ResourceQuotaScope = "NotBestEffort"
)

type ResourceQuotaSpec struct {
	Hard   ResourceList `json:"hard,omitempty"`
	Scopes []ResourceQuotaScope `json:"scopes,omitempty"`
}

type ResourceQuotaStatus struct {
	Hard ResourceList `json:"hard,omitempty"`
	Used ResourceList `json:"used,omitempty"`
}

type ResourceQuota struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Spec   ResourceQuotaSpec `json:"spec,omitempty"`

	Status ResourceQuotaStatus `json:"status,omitempty"`
}

type ResourceQuotaList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []ResourceQuota `json:"items"`
}

type Secret struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`
	Data map[string][]byte `json:"data,omitempty"`

	Type SecretType `json:"type,omitempty"`
}

const MaxSecretSize = 1 * 1024 * 1024

type SecretType string

const (
	SecretTypeOpaque SecretType = "Opaque"

	SecretTypeServiceAccountToken SecretType = "kubernetes.io/service-account-token"

	ServiceAccountNameKey = "kubernetes.io/service-account.name"
	ServiceAccountUIDKey = "kubernetes.io/service-account.uid"
	ServiceAccountTokenKey = "token"
	ServiceAccountKubeconfigKey = "kubernetes.kubeconfig"
	ServiceAccountRootCAKey = "ca.crt"
	ServiceAccountNamespaceKey = "namespace"

	SecretTypeDockercfg SecretType = "kubernetes.io/dockercfg"

	DockerConfigKey = ".dockercfg"

	SecretTypeTLS SecretType = "kubernetes.io/tls"

	TLSCertKey = "tls.crt"
	TLSPrivateKeyKey = "tls.key"
)

type SecretList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []Secret `json:"items"`
}

type ConfigMap struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Data map[string]string `json:"data,omitempty"`
}

type ConfigMapList struct {
	TypeMeta `json:",inline"`

	ListMeta `json:"metadata,omitempty"`

	Items []ConfigMap `json:"items,omitempty"`
}

type ComponentConditionType string

const (
	ComponentHealthy ComponentConditionType = "Healthy"
)

type ComponentCondition struct {
	Type    ComponentConditionType `json:"type"`
	Status  ConditionStatus `json:"status"`
	Message string `json:"message,omitempty"`
	Error   string `json:"error,omitempty"`
}

type ComponentStatus struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Conditions []ComponentCondition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type"`
}

type ComponentStatusList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`

	Items []ComponentStatus `json:"items"`
}

type DownwardAPIVolumeSource struct {
	Items []DownwardAPIVolumeFile `json:"items,omitempty"`
}

type DownwardAPIVolumeFile struct {
	Path     string `json:"path"`
	FieldRef ObjectFieldSelector `json:"fieldRef"`
}

type SecurityContext struct {
	Capabilities           *Capabilities `json:"capabilities,omitempty"`
	Privileged             *bool `json:"privileged,omitempty"`
	SELinuxOptions         *SELinuxOptions `json:"seLinuxOptions,omitempty"`
	RunAsUser              *int64 `json:"runAsUser,omitempty"`
	RunAsNonRoot           *bool `json:"runAsNonRoot,omitempty"`
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty"`
}

type SELinuxOptions struct {
	User  string `json:"user,omitempty"`
	Role  string `json:"role,omitempty"`
	Type  string `json:"type,omitempty"`
	Level string `json:"level,omitempty"`
}

type RangeAllocation struct {
	TypeMeta `json:",inline"`
	ObjectMeta `json:"metadata,omitempty"`

	Range string `json:"range"`
	Data  []byte `json:"data"`
}

const (
	DefaultSchedulerName = "default-scheduler"
)


//job 相关
type Job struct {
	TypeMeta `json:",inline"`
	// Standard object's metadata.
	// More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#metadata
	ObjectMeta `json:"metadata,omitempty"`

	// Spec is a structure defining the expected behavior of a job.
	// More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#spec-and-status
	Spec   JobSpec `json:"spec,omitempty"`

	// Status is a structure describing current status of a job.
	// More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#spec-and-status
	Status JobStatus `json:"status,omitempty"`
}

// JobList is a collection of jobs.
type JobList struct {
	TypeMeta `json:",inline"`
	// Standard list metadata
	// More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#metadata
	ListMeta `json:"metadata,omitempty"`

	// Items is the list of Job.
	Items []Job `json:"items"`
}

// JobSpec describes how the job execution will look like.
type JobSpec struct {
	Parallelism           *int32 `json:"parallelism,omitempty"`

	Completions           *int32 `json:"completions,omitempty"`

	ActiveDeadlineSeconds *int64 `json:"activeDeadlineSeconds,omitempty"`

	Selector              *LabelSelector `json:"selector,omitempty"`

	ManualSelector        *bool `json:"manualSelector,omitempty"`

	Template              PodTemplateSpec `json:"template"`
}

type JobStatus struct {
	Conditions     []JobCondition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type"`

	StartTime      string `json:"startTime,omitempty"`

	CompletionTime *string `json:"completionTime,omitempty"`

	Active         int32 `json:"active,omitempty"`

	Succeeded      int32 `json:"succeeded,omitempty"`

	Failed         int32 `json:"failed,omitempty"`
}

type JobConditionType string

const (
	JobComplete JobConditionType = "Complete"
	JobFailed JobConditionType = "Failed"
)

// JobCondition describes current state of a job.
type JobCondition struct {
	// Type of job condition, Complete or Failed.
	Type               JobConditionType `json:"type"`
	// Status of the condition, one of True, False, Unknown.
	Status             ConditionStatus `json:"status"`
	// Last time the condition was checked.
	LastProbeTime      Time `json:"lastProbeTime,omitempty"`
	// Last time the condition transit from one status to another.
	LastTransitionTime Time `json:"lastTransitionTime,omitempty"`
	// (brief) reason for the condition's last transition.
	Reason             string `json:"reason,omitempty"`
	// Human readable message indicating details about last transition.
	Message            string `json:"message,omitempty"`
}

// A label selector is a label query over a set of resources. The result of matchLabels and
// matchExpressions are ANDed. An empty label selector matches all objects. A null
// label selector matches no objects.
type LabelSelector struct {
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels      map[string]string `json:"matchLabels,omitempty"`
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []LabelSelectorRequirement `json:"matchExpressions,omitempty"`
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type LabelSelectorRequirement struct {
	// key is the label key that the selector applies to.
	Key      string `json:"key" patchStrategy:"merge" patchMergeKey:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators ard In, NotIn, Exists and DoesNotExist.
	Operator LabelSelectorOperator `json:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values   []string `json:"values,omitempty"`
}

// A label selector operator is the set of operators that can be used in a selector requirement.
type LabelSelectorOperator string

const (
	LabelSelectorOpIn LabelSelectorOperator = "In"
	LabelSelectorOpNotIn LabelSelectorOperator = "NotIn"
	LabelSelectorOpExists LabelSelectorOperator = "Exists"
	LabelSelectorOpDoesNotExist LabelSelectorOperator = "DoesNotExist"
)
